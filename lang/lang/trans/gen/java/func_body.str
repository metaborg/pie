module gen/java/func_body

imports

  libspoofax/stratego/debug

  src-gen/signatures/-
  signatures/metaborg-java-sig
  signatures/java/arrays/-
  signatures/java/classes/-
  signatures/java/interfaces/-
  signatures/java/lexical/-
  signatures/java/literals/-
  signatures/java/names/-
  signatures/java/packages/-
  signatures/java/statements/-
  signatures/java/types/-
  signatures/java/expressions/-

  statics

  gen/java/func_def
  gen/java/binder
  gen/java/type
  gen/java/ast-util
  gen/idtype-tuples
  gen/debug
  gen/util

rules

  // tries to apply p2j-ast-exp, returns ""
  try-p2j-ast-exp = pie-try-debug(p2j-ast-exp|"p2j-ast-exp") <+ !([], NewInstance(None(), [], "Object", [], None(), []))

rules // Expression composition

  // p2j-ast-exp: Pie to Java AST expressions
  // Takes a Pie AST Expression node and compiles it to a pair of
  // (List of Java statements, Java Node with an expression for the value of the Pie AST node)
  p2j-ast-exp:
    e@Block(exps) -> result
    with
      numExps              := <length> exps
    ; restExps             := <take(|<dec> numExps)> exps
    ; restStmts            := <map(try-p2j-ast-exp); map(Fst); concat> restExps
    ; lastExp              := <last> exps
    ; (lastStmts, lastVal) := <try-p2j-ast-exp> lastExp
    ; stmts                := <concat> [restStmts, lastStmts]
    ; blockResultVal       := <newname> "blockResult"
    ; ty                   := <p2j-ast-type-sig> <pie-ast-type> e
    ; resultStmts          := [
      LocVarDeclStm(LocalVarDecl([Final()], <java-classType-to-unannType> ty, [VariableDecl(Id(blockResultVal))])),
      Block(<concat> [
        stmts,
        [ ExpressionStatement(Assign(ExpressionName(Id(blockResultVal)), lastVal)) ]
      ])
    ]
    ; result                    := (resultStmts, blockResultVal)

  p2j-ast-exp: EmptyBlock() -> <p2j-ast-exp> UnitLit()

rules // Unary expressions

  p2j-ast-exp:
    ToNullable(exp) -> <try-p2j-ast-exp> exp // non-primitive Java types are always nullable

  p2j-ast-exp:
    n@ToNonNullable(exp) -> result
    with
      <add-import> "java.util.Objects"
    ; <add-import> "mb.pie.api.ExecException"
    ; (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; tmpVarName         := <newname> "exp"
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> n
    ; stmts              := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [VariableDecl(Id(tmpVarName))]
          ))
        , Try(
            Block(
              [ ExpressionStatement(Assign(
                  ExpressionName(Id(tmpVarName))
                , InvokeQExp(ExpressionName("Objects"), None(), "requireNonNull", [expVal])
                ))
              ]
            )
          , [ Catch(
                CatchParam(
                  []
                , CatchType(ClassType(Id("NullPointerException"), None()), [])
                , VariableDecl(Id("ex"))
                )
              , Block(
                  [ Throw(NewInstance(None(), [], Id("ExecException"), [], None(), [
                      StringLiteral($["Tried to cast a null value to NonNullable"])
                    , ExpressionName(Id("ex"))
                    ]))
                  ]
                )
              )
            ]
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [tmpVarName];
        //   try {
        //     [tmpVarName] = Objects.requireNonNull([expVal]);
        //   } catch (NullpointerException ex) {
        //     throw new ExecException("Tried to cast a null value to NonNullable", ex);
        //   }
      ]
    ; result             := (stmts, tmpVarName)


  p2j-ast-exp:
    Not(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; result             := (expStmts, Not(expVal))

rules // Binary expressions

  // p2j-ast-binexp(combine-vals):
  //   (lExp, rExp) -> (Java statements, Java expression value AST node)
  // a general function for handline a binexp.
  // It takes a strategy combine-vals to combine the values of both sides
  p2j-ast-binexp(combine-vals):
    (lExp, rExp) -> result
    with
      (lStmts, lExpVal) := <try-p2j-ast-exp> lExp
    ; (rStmts, rExpVal) := <try-p2j-ast-exp> rExp
    ; stmts             := <concat> [lStmts, rStmts]
    ; exp               := <combine-vals> (lExpVal, rExpVal)
    ; result            := (stmts, exp)

  p2j-ast-exp: Eq(lExp, rExp) -> <p2j-ast-binexp(
      \(e1, e2) -> InvokeQExp(ExpressionName(Id("Objects")), None(), Id("equals"), [e1, e2])\
    )> (lExp, rExp)
    with
      <add-import> "java.util.Objects"
  p2j-ast-exp: Neq(lExp, rExp) -> <p2j-ast-binexp(
      \(e1, e2) -> Not(InvokeQExp(ExpressionName(Id("Objects")), None(), Id("equals"), [e1, e2]))\
    )> (lExp, rExp)
    with
      <add-import> "java.util.Objects"
  p2j-ast-exp: Lor(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> LazyOr(e1, e2)\)> (lExp, rExp)
  p2j-ast-exp: Land(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> LazyAnd(e1, e2)\)> (lExp, rExp)

rules // Control flow

  p2j-ast-exp:
    If(condExp, branch) -> result
    with
      (condStmts, condExpVal) := <try-p2j-ast-exp> condExp
    ; (branchStmts, _)        := <try-p2j-ast-exp> branch
    ; stmts                   := <concat> [condStmts, [If(condExpVal, Block(branchStmts))]]
    ; exp                     := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                  := (stmts, exp)

  p2j-ast-exp:
    e@IfElse(condExp, trueExp, falseExp) -> result
    with
      (condStmts, condVal)   := <try-p2j-ast-exp> condExp
    ; (trueStmts, trueVal)   := <try-p2j-ast-exp> trueExp
    ; (falseStmts, falseVal) := <try-p2j-ast-exp> falseExp
    ; resultName             := <newname> "ifResult"
    ; trueBlockStmts         := <concat> [trueStmts, [ExpressionStatement(Assign(ExpressionName(Id(resultName)), trueVal))]]
    ; falseBlockStmts        := <concat> [falseStmts, [ExpressionStatement(Assign(ExpressionName(Id(resultName)), falseVal))]]
    ; ty                     := <p2j-ast-type-sig> <pie-ast-type> e
    ; stmts                  := <concat> [
      condStmts,
      [
        LocVarDeclStm(LocalVarDecl([Final()], <java-classType-to-unannType> ty, [VariableDecl(Id(resultName))])),
        IfElse(condVal, Block(trueBlockStmts), Block(falseBlockStmts))
      ]]
    ; result                 := (stmts, resultName)

  p2j-ast-exp:
    Add(lExp, rExp) -> result
    with
      (lStmts, lExpVal) := <try-p2j-ast-exp> lExp
    ; (rStmts, rExpVal) := <try-p2j-ast-exp> rExp
    ; lType             := <pie-ast-type> lExp
    ; rType             := <pie-ast-type> rExp
    ; (expStmts, exp)   := <p2j-ast-add(|lType, rType)> (lExpVal, rExpVal)
    ; stmts             := <concat> [lStmts, rStmts, expStmts]
    ; result            := (stmts, exp)

  // p2j-ast-add(|lType, rType): (lExp, rExp) ->
  //   (List of Java AST statements, Java expression AST Node)
  // Helper function that converts the Add into the correct AST Node
  // based on the types of the left and right side (lType and rType)
  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([], Add(lExp, rExp))
    where
      (IntType(), IntType()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([], Add(lExp, rExp))
    where
      (StrType(), _) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> result
    where
      (PathType(), PathType()) := (lType, rType)
    with
      <add-import> "mb.resource.ResourceRuntimeException"
    ; <add-import> "mb.pie.api.ExecException"
    ; tmpResultName := <newname> "addResult"
    ; stmts         := [
        LocVarDeclStm(LocalVarDecl(
          [Final()]
        , ClassType(Id("FSPath"), None())
        , [VariableDecl(Id(tmpResultName))]
        ))
      , Try(
          Block(
            [ ExpressionStatement(Assign(
                ExpressionName(Id(tmpResultName))
              , InvokeQExp(lExp, None(), Id("appendRelativePath"), [rExp])
              ))
            ]
          )
        , [ Catch(
              CatchParam(
                []
              , CatchType(ClassType(Id("ResourceRuntimeException"), None()), [])
              , VariableDecl(Id("e"))
              )
            , Block([Throw(
                NewInstance(
                  None()
                , []
                , Id("ExecException")
                , []
                , None()
                , [ StringLiteral($["Could not append path: it is an absolute path"])
                  , ExpressionName(Id("e"))
                  ]
                )
              )])
            )
          ]
        )
      ]
      // Note: meaning of this AST:
      //   final FSPath [tmpResultName];
      //   try {
      //     [tmpResultName] = [lExp].appendRelativePath([rExp]);
      //   } catch (ResourceRuntimeException e) {
      //     throw new ExecException("Could not append path: it is an absolute path", e);
      //   }
    ; exp           := tmpResultName
    ; result        := (stmts, exp)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([], InvokeQExp(lExp, None(), Id("appendOrReplaceWithPath"), [rExp]))
    // Note: meaning of this AST: [lExp].appendSegment([rExp])
    where
      (PathType(), StrType()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([],
      InvokeQExp(
        InvokeQExp(
          ExpressionName(Id("Stream"))
        , None()
        , Id("concat")
        , [ InvokeQExp(lExp, None(), Id("stream"), [])
          , InvokeQExp(
              ExpressionName(Id("Stream"))
            , None()
            , Id("of")
            , [rExp]
            )
          ]
        )
      , None()
      , Id("collect")
      , [ InvokeQExp(
            ExpressionName(Id("Collectors"))
          , None()
          , Id("toCollection")
          , [MethodReferenceCType(ClassType([], Id("ArrayList"), None()), None())]
          )
        ]
      )
    )
    // Note: meaning of this AST:
    //   Stream.concat(([lExp]).stream(), Stream.of([rExp])).collect(Collectors.toCollection(ArrayList::new))
    where
      (ListType(a), a) := (lType, rType)
    with
      <add-import> "java.util.ArrayList"
    ; <add-import> "java.util.stream.Collectors"
    ; <add-import> "java.util.stream.Stream"

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([],
      InvokeQExp(
        InvokeQExp(
          ExpressionName(Id("Stream"))
        , None()
        , Id("concat")
        , [ InvokeQExp(lExp, None(), Id("stream"), [])
          , InvokeQExp(rExp, None(), Id("stream"), [])
          ]
        )
      , None()
      , Id("collect")
      , [ InvokeQExp(
            ExpressionName(Id("Collectors"))
          , None()
          , Id("toCollection")
          , [MethodReferenceCType(ClassType([], Id("ArrayList"), None()), None())]
          )
        ]
      )
    )
    // Note: meaning of this AST:
    // Stream.concat(([lExp]).stream(), ([rExp]).stream()).collect(Collectors.toCollection(ArrayList::new))]
    where
      (ListType(a), ListType(a)) := (lType, rType)
    with
      <add-import> "java.util.ArrayList"
    ; <add-import> "java.util.stream.Collectors"
    ; <add-import> "java.util.stream.Stream"

  p2j-ast-exp:
    e@ListComprehension(mapExp, binder, listExp) -> result
    where
      ListType(pieElemTy) := <pie-ast-type> listExp
    with
      <add-import> "java.util.ArrayList"
    ; (listStmts, listExpVal) := <try-p2j-ast-exp> listExp
    ; elemTy                  := <p2j-ast-type-sig> pieElemTy
    ; (mapStmts, mapExpVal)   := <try-p2j-ast-exp> mapExp
    ; (assignments, varId)    := <bind-tuples-to-ast-assignments> (binder, pieElemTy)
    ; comprehensionTmpVarName := <newname> "comprehensionResult"
    ; innerStmts              := <concat> [
        assignments,
        mapStmts,
        [ ExpressionStatement(
            InvokeQExp(
              ExpressionName(
                Id(comprehensionTmpVarName))
              , None()
              , Id("add")
              , [ mapExpVal ]
            )
          )
        ]
      ]
    ; ty                      := <p2j-ast-type-sig> <pie-ast-type> e
    ; stmts                   := <concat> [
        listStmts,
        [
          LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(comprehensionTmpVarName))
              , NewInstance(None(), [], Id("ArrayList"), [], Some(Diamond()), [])
              )
            ]
          ))
        , ForEach(
            []
          , <java-classType-to-unannType> elemTy
          , VariableDecl(Id(varId))
          , listExpVal
          , Block(innerStmts)
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [comprehensionTmpVarName] = new ArrayList<>();
        //   for ([elemTy] [elemName] : [listExpVal]) {
        //     [innerStmts]
        //   }
      ]
    ; result                     := (stmts, comprehensionTmpVarName)


  p2j-ast-exp:
    e@ListComprehension(mapExp, binder, listExp) -> result
    where
      EmptyListType() := <pie-ast-type> listExp
    with
      <add-import> "java.util.ArrayList"
    ; (listStmts, listExpVal) := <try-p2j-ast-exp> listExp
    ; comprehensionTmpVarName := <newname> "comprehensionResult"
    ; ty                      := <p2j-ast-type-sig> <pie-ast-type> e
    ; stmts                   := <concat> [
        listStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(comprehensionTmpVarName))
              , NewInstance(None(), [], Id("ArrayList"), [], Some(Diamond()), [])
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //   final [ty] [comprehensionTmpVarName] = new ArrayList<>();
      ]
    ; result                     := (stmts, comprehensionTmpVarName)



rules // Binding

  p2j-ast-exp:
    e@ValDec(binder, exp) -> result
    with
      pieTy                := <pie-ast-type> binder
    ; expTy                := <p2j-ast-type-sig> pieTy
    ; (expStmts, expVal)   := <try-p2j-ast-exp> exp
    ; (assignments, varId) := <bind-tuples-to-ast-assignments> (binder, pieTy)
    ; stmts                := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> expTy
          , [VariableDeclInit(VariableDecl(Id(varId)), expVal)]
          ))
        ]
      , assignments
      ]
    ; resultExp            := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result               := (stmts, resultExp)

  // bind-tuples-to-assignments:
  // (Pie Binder (Bind or TBind), Pie ExpressionType) -> (assignments, varName)
  bind-tuples-to-ast-assignments:
    (SingleBinder(bind), _) -> ([], <p2j-ast-bind> bind)

  bind-tuples-to-ast-assignments:
    (TupleBinder(binds), expTy) -> result
    with
      varIds         := <map(p2j-ast-bind)> binds
    ; TupleType(tys) := expTy
    ; javaTys        := <map(p2j-ast-type-sig)> tys
    ; bindList       := <zip> (varIds, javaTys)
    ; tmpVar         := <newname> "tmpTupleVar"
    ; assignments    := <nmap-par(bind-tuple-to-ast | 1, tmpVar)> bindList
    ; result         := (assignments, tmpVar)

  // nmap that passes an extra parameter to the strategy
  nmap-par(s : Int * c * a -> b | i, par) =
    ?[] + [s(|i,par) | nmap-par(s | <inc> i, par)]

  bind-tuple-to-ast(|i, tmpVar):
    (varId, ty) -> LocVarDeclStm(LocalVarDecl(
      [Final()]
    , <java-classType-to-unannType> ty
    , [ VariableDeclInit(
          VariableDecl(Id(varId))
        , InvokeQExp(ExpressionName(Id(tmpVar)), None(), Id($[component[i]]), [])
        )
      ]
    ))

rules // References

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|ExpressionName(Id(varId)))> r)
    where
      LocalValKind() := <pie-ast-ref-prop(|"kind")> varId

  p2j-ast-exp:
    r@Ref(varId) -> <error(|"value kind of declaration is set to parameter but function has 0 parameters")> r
    where
      InputValKind() := <pie-ast-ref-prop(|"kind")> varId
    ; 0 := <InputKind>

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|ExpressionName(Id("input")))> r)
    where
      InputValKind() := <pie-ast-ref-prop(|"kind")> varId
    ; 1 := <InputKind>

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|InvokeQExp(
      ExpressionName(Id("input")), None(), Id($[get_[varId]]), [])
    )> r)
    where
      InputValKind() := <pie-ast-ref-prop(|"kind")> varId
    ; 2 := <InputKind>

  // p2j-ast-ref-add-transient-val(|ast): Pie Ref -> Java reference
  p2j-ast-ref-add-transient-val(|ast):
    ref -> InvokeQExp(ast, None(), Id("getValue"), [])
    where
      <p2j-ast-ref-is-transient> ref

  p2j-ast-ref-add-transient-val(|ast):
    ref -> ast
    where
      <not(p2j-ast-ref-is-transient)> ref

  // succeeds if the current term is transient
  p2j-ast-ref-is-transient =
      pie-ast-type
    ; (?DataType(<id>) <+ ?NullableType(DataType(<id>)))
    ; pie-get-data-mods
    ; collect-one(?Transient())

rules // Java foreign function calls

  p2j-ast-exp:
    c@Call(moduleList, name, typeArgs, argExps) -> (stmts, callExpr)
    where
      JavaForeignFuncKind() := <pie-ast-ref-prop(|"kind")> name
    with
      javaClassId                 := <pie-func-name-to-javaClassId> name
    ; javaTypeArgs                := <p2j-ast-type-args> typeArgs
    ; expressionNameJavaClassId   := <java-qualifiedClass-to-expressionName> <string-tokenize(|['.'])> javaClassId
    ; javaMethodId                := <pie-ast-ref-prop(|"javaMethodId")> name
    ; (argExpsStmts, argExpsVals) := <unzip> <map(try-p2j-ast-exp)> argExps
    ; javaExpr                    :=
        InvokeQExp(
          expressionNameJavaClassId
        , javaTypeArgs
        , Id(javaMethodId)
        , argExpsVals
        )
      // Note: meaning of this AST:
      //       [javaClassId].<[javaTypeArgs]>[javaMethodId]([argExpsVals])
    ; (callStmts, callExpr)       := <p2j-ast-exp-call> (name, javaExpr)
    ; stmts                       := <concat> [<concat> argExpsStmts, callStmts]

  p2j-ast-exp:
    c@Call(moduleList, name, typeArgs, exps) -> (stmts, callExpr)
    where
      JavaForeignConstructorKind() := <pie-ast-ref-prop(|"kind")> name
    with
      javaClassId           := <pie-func-name-to-javaClassId> name
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; javaTypeArgs          := <p2j-ast-type-args> typeArgs
    ; javaExpr              := NewInstance(javaTypeArgs, [], Id(javaClassId), [], None(), expsVals)
      // Note: meaning of this AST:
      //       new[javaTypeArgs] [javaClassId].([expsVals])
    ; (callStmts, callExpr) := <p2j-ast-exp-call> (name, javaExpr)
    ; stmts                 := <concat> [<concat> expsStmts, callStmts]

rules // Qualified function calls

  p2j-ast-exp:
    call@QCall(exp, name, typeArgs, argExps) -> (stmts, callExpr)
    where
      JavaForeignMethodKind() := <pie-ast-ref-prop(|"kind")> call
    with
      (expStmts, expVal)          := <try-p2j-ast-exp> exp
    ; (argExpsStmts, argExpsVals) := <unzip> <map(try-p2j-ast-exp)> argExps
    ; javaExpr                    := InvokeQExp(expVal, None(), Id(name), argExpsVals)
      // Note: meaning of this AST:
      //       [expVal].[funcId]([argExpsVals]);
    ; (callStmts, callExpr)       := <p2j-ast-exp-call> (name, javaExpr)
    ; stmts                       := <concat> [expStmts, <concat> argExpsStmts, callStmts]

  p2j-ast-exp: call@QCall(exp, "get", _, argExps) -> result
    where
      PieBuiltInFuncKind(SupplierGet()) := <pie-ast-ref-prop(|"kind")> call
    with
      <add-import> "java.io.IOException"
    ; (expStmts, expVal)  := <p2j-ast-exp> exp
    ; SupplierType(pieTy) := <pie-ast-type> exp
    ; ty                  := <p2j-ast-type-sig> pieTy
    ; callResultName      := <newname> "callResult"
    ; stmts               := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [VariableDecl(Id(callResultName))]
          ))
        , ExpressionStatement(Assign(
            ExpressionName(Id(callResultName))
          , InvokeQExp(
              ExpressionName(Id("execContext"))
            , None()
            , Id("require")
            , [ expVal ]
            )
          ))
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName];
        //   [callResultName] = execContext.require([expVal]);
      ]
    ; result               := (stmts, callResultName)

rules // PIE function calls

  p2j-ast-exp:
    Call(moduleList, name, typeArgs, argExps) -> (stmts, callExpr)
    where
      <pie-ast-ref-prop(|"kind"); (?PieForeignFuncKind() <+ ?PieFuncKind())> name
    with
      <add-import> "javax.inject.Provider"
    ; javaClassId            := <pie-func-name-to-javaClassId> <pie-get-decl> name
    ; safeJavaClassId        := <pie-sanitize-class-id> javaClassId
    ; javaTypeArgs           := <p2j-ast-type-args> typeArgs
    ; (inputStmts, inputArg) := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> argExps
    ; expr                   :=
        InvokeQExp(
          ExpressionName(Id("execContext"))
        , None()
        , Id("require")
        , [ InvokeQExp(
              ExpressionName(Id($[_[safeJavaClassId]]))
            , javaTypeArgs
            , Id("get")
            , []
            )
          , inputArg
          ]
        )
        // Note: meaning of this AST
        //       execContext.require(_[safeJavaClassId].get(), [inputArg])
    ; (callStmts, callExpr)  := <p2j-ast-exp-call> (name, expr)
    ; stmts                  := <concat> [inputStmts, callStmts]
    ; rules(InjectValues :+= (
        $[_[safeJavaClassId]],
        ClassType([], Id("Provider"), Some(TypeArguments([ClassType([], Id(javaClassId), javaTypeArgs)])))
      ))

  /**
   * p2j-ast-exp-call: (name, javaExpr) -> (stmts, exp)
   * Type: (string, Java Expression) -> (Java Statement*, Java Expression)
   *
   * Takes a pie function name and a java expression and returns a list with
   * single statement `final [ty] callResultX = [expr]` where `X` is a number
   * to make the callResult identifier unique, [ty] is the type of the java
   * expression (extracted from [name]), and [expr] is the java expression.
   * The returned Java Expression is just the identifier [callResultX]
   */
  p2j-ast-exp-call:
    (name, javaExpr) -> (stmts, exp)
    with
      callResultName                := <newname> "callResult"
    ; FuncRefType(_, _, outputType) := <pie-ast-type> name
    ; ty                            := <p2j-ast-type-sig> outputType
    ; stmts                         := [
        LocVarDeclStm(LocalVarDecl(
          [Final()]
        , <java-classType-to-unannType> ty
        , [ VariableDeclInit(
              VariableDecl(Id(callResultName))
            , javaExpr
            )
          ]
        ))
      ]
      // Note: meaning of this AST:
      //       final [ty] [callResultName] = [javaExpr]
    ; exp                           := ExpressionName(Id(callResultName))

  // p2j-ast-exp-pie-call-inputexp(|javaClassId): exps -> (stmts, input ast node)
  // Converts a list of Pie expressions to a list of statements and an AST node that
  // can be used as input for a Pie task. Will be either Unit, an arbitrary AST node
  // or an Input AST node for the provided JavaClass (from JavaClassId)
  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> <try-p2j-ast-exp> UnitLit()
    where
      0 := <length> exps

  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> result
    where
      1 := <length> exps
    with
      [exp]  := exps
    ; result := <try-p2j-ast-exp> exp

  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> result
    where
      length := <length> exps
    ; <gt> (length, 1)
    with
      (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := NewInstance(
          None()
        , []
        , Id(javaClassId)
        , [QualifiedId([], "Input")]
        , None()
        , expsVals
        )
      // Note: meaning of this AST:
      //       new [javaClassId].Input([expsVals])
    ; result                := (stmts, exp)

  p2j-ast-exp: CreateSupplier(_, typeArg, [arg]) -> result
    with
      <add-import> "mb.pie.api.Supplier"
    ; <add-import> "mb.pie.api.ValueSupplier"
    ; (argStmts, argVal) := <p2j-ast-exp> arg
      // todo: get type from typeArg, not arg. (could also get full type directly from CreateSupplier node?)
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> arg
    ; supplierName       := <newname> "supplier"
    ; stmts              := <concat> [
        argStmts,
        [ LocVarDeclStm(
            LocalVarDecl(
              [Final()]
            , ClassType(
                Id("Supplier")
              , Some(TypeArguments([ty]))
              )
            , [ VariableDeclInit(
                  VariableDecl(Id(supplierName))
                , NewInstance(None(), [], "ValueSupplier", [], None(), [argVal])
                )
              ]
            )
          )
        ]
        // Note: meaning of this AST:
        //   final Supplier<[ty]> [supplierName] = new ValueSupplier([argVal]);
      ]
    ; result             := (stmts, supplierName)


  p2j-ast-exp: t@TaskSupplier(moduleList, funcId, _, typeArgs, args) -> result
    with
      <add-import> "javax.inject.Provider"
    ; javaClassId          := <pie-func-name-to-javaClassId> funcId
    ; safeJavaClassId      := <pie-sanitize-class-id> javaClassId
    ; javaTypeArgs         := <p2j-ast-type-args> typeArgs
    ; (argStmts, inputArg) := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> args
    ; callResultName       := <newname> "callResult"
    ; ty                   := <p2j-ast-type-sig> <pie-ast-type> t
    ; stmts                := <concat> [
        argStmts,
        [ LocVarDeclStm(
            LocalVarDecl(
              [Final()]
            , <java-classType-to-unannType> ty
            , [ VariableDeclInit(
                  VariableDecl(Id(callResultName))
                , InvokeQExp(
                    InvokeQExp(
                      ExpressionName(Id($[_[safeJavaClassId]]))
                    , None()
                    , Id("get")
                    , []
                    )
                  , None()
                  , Id("createSupplier")
                  , [ inputArg ]
                  )
                )
              ]
            )
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName] = [javaClassName].createSupplier([inputArg]);
      ]
    ; result               := (stmts, callResultName)
    ; rules(InjectValues :+= (
        $[_[safeJavaClassId]],
        ClassType([], Id("Provider"), Some(TypeArguments([ClassType([], Id(javaClassId), javaTypeArgs)])))
      ))

rules // Path operations

  p2j-exp:
    r@RequiresPath(exp, filterOpt, stamper) -> result
    with
      (expStmts, expVal)         := <p2j-ast-exp> exp
    ; (stamperStmts, stamperVal) := <p2j-ast-stamper> (filterOpt, stamper)
    ; stmts                      := <concat> [
        expStmts,
        stamperStmts,
        [ ExpressionStatement(InvokeQExp(
            ExpressionName(Id("execContext"))
          , None()
          , Id("require")
          , [expVal, stamperVal]
          ))
        ]
        // Note: meaning of this AST:
        //       execContext.require([expVal], [stamperVal]);
      ]
    ; resultExp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                     := (stmts, resultExp)

  p2j-exp:
    GeneratesPath(exp, stamper) -> result
    with
      (expStmts, expVal)         := <p2j-ast-exp> exp
    ; (stamperStmts, stamperVal) := <p2j-ast-stamper> (None(), stamper)
    ; stmts                      := <concat> [
        expStmts,
        stamperStmts,
        [ ExpressionStatement(InvokeQExp(
            ExpressionName(Id("execContext"))
          , None()
          , Id("provide")
          , [expVal, stamperVal]
          ))
        ]
        // Note: meaning of this AST:
        //       execContext.provide([expVal], [stamperVal]);
      ]
    ; resultExp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                     := (stmts, resultExp)

  // p2j-stamper: (filter|None(), stamper) -> (stmts, expression value)
  p2j-ast-stamper:
    (None(), Modified()) -> ([], InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("modified"), []))
    // Note: meaning of this AST: FileSystemStampers.modified()
  p2j-ast-stamper:
    (None(), Modified()) -> ([], InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("hash"), []))
    // Note: meaning of this AST: FileSystemStampers.hash()
  p2j-ast-stamper:
    (filter, Modified()) -> result
    where
      <not(?None())> filter
    with
      (stmts, filterVal) := <p2j-ast-filter> filter
    ; exp                := InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("modified"), [filterVal])
      // Note: meaning of this AST: FileSystemStampers.modified([filterVal])
    ; result             := (stmts, exp)

  p2j-ast-stamper:
    (filter, Hash()) -> result
    where
      <not(?None())> filter
    with
      (stmts, filterVal) := <p2j-ast-filter> filter
    ; exp                := InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("hash"), [filterVal])
      // Note: meaning of this AST: FileSystemStampers.hash([filterVal])
    ; result             := (stmts, exp)

  p2j-ast-exp:
    l@ListPath(exp, filterOpt) ->
      <p2j-ast-dir(p2j-ast-filter-create-param-list-for-list|"list")> (l, exp, filterOpt)
  p2j-ast-exp:
    w@WalkPath(exp, filterOpt) ->
      <p2j-ast-dir(p2j-ast-filter-create-param-list-for-walk|"walk")> (w, exp, filterOpt)

  // p2j-ast-dir(create-param-list | funcName):
  //   (astNode, exp, filterOpt) -> (Java statements, Java expression value)
  // Combined function for both ListPath and WalkPath.
  // Input:
  // - a strategy create-params-list which is passed on to p2j-ast-filter-to-params-list.
  // - a function name to call (funcName)
  // - operates on terms that are a Triple of:
  //   + a Pie AST node (ListPath or WalkPath)
  //   + the expression from that AST node (said expression represents a path)
  //   + the filterOption from that AST node. This is also known as a matcher.
  p2j-ast-dir(create-param-list | funcName):
    (astNode, exp, filterOpt) -> result
    with
      <add-import> "mb.resource.fs.FSResource"
    ; <add-import> "java.util.stream.Collectors"
    ; <add-import> "java.util.ArrayList"
    ; (expStmts, expVal)      := <try-p2j-ast-exp> exp
    ; (matcherStmts, matcher) := <p2j-ast-filter> filterOpt
    ; funcParamList           := <p2j-ast-filter-to-params-list(create-param-list)> (filterOpt, matcher)
    ; ty                      := <p2j-ast-type-sig> <pie-ast-type> astNode
    ; expVarName              := <newname> "dirResult"
    ; stmts                   := <concat> [
        expStmts,
        matcherStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], <java-classType-to-unannType> ty, [VariableDeclInit(
          VariableDecl(Id(expVarName)),
          InvokeQExp(
            InvokeQExp(
              InvokeQExp(
                InvokeQExp(ExpressionName(Id("execContext")), None(), Id("require"), [expVal])
                , None()
                , funcName
                , funcParamList
                )
            , None()
            , Id("map")
            , [MethodReferenceRType(ClassType([], Id("FSResource"), None()), None(), Id("getPath"))]
            )
          , None()
          , Id("collect")
          , [ InvokeQExp(
                ExpressionName(Id("Collectors"))
              , None()
              , Id("toCollection")
              , [MethodReferenceCType(ClassType([], Id("ArrayList"), None()), None())]
              )
            ]
          )
        )]))]
        // Note: meaning of this AST:
        //   final [ty] [expVarName] = execContext.require([expVal]).[funcName]([funcParamList])
        //   .map(FSResource::getPath)
        //   .collect(Collectors.toCollection(ArrayList::new));
      ]
    ; result                  := (stmts, expVarName)

  // p2j-ast-filter-to-params-list(create-param-list):
  //   (matcherPie, matcherJava) -> parameter list
  // creates a list of parameters for the call to the dir-function in p2j-ast-dir
  // create-param-list should be one of the p2j-filter-create-param-list-for-X strategies
  p2j-ast-filter-to-params-list(create-param-list):
    (None(), _) -> []
  p2j-ast-filter-to-params-list(create-param-list):
    (matcherPie, matcherJava) -> <create-param-list> matcherJava
    where
      <not(?None())> matcherPie

  // p2j-ast-filter-create-param-list-for-[funcName]: matcher -> param list
  // Given a Java AST node for a matcher, create a list of parameters
  // for the Pie API method funcName
  p2j-ast-filter-create-param-list-for-list:
    matcher -> [NewInstance(None(), [], Id("PathResourceMatcher"), [], None(), [matcher])]
    // Note: meaning of this AST: new PathResourceMatcher([matcher])
    with
      <add-import> "mb.resource.hierarchical.match.PathResourceMatcher"
  p2j-ast-filter-create-param-list-for-walk:
    matcher -> [
      NewInstance(None(), [], "PathResourceWalker", [], None(), [
        NewInstance(None(), [], Id("NoHiddenPathMatcher"), [], None(), [])
      ]),
      NewInstance(None(), [], Id("PathResourceMatcher"), [], None(), [matcher])
    ]
    with
      <add-import> "mb.resource.hierarchical.walk.PathResourceWalker"
    ; <add-import> "mb.resource.hierarchical.match.path.NoHiddenPathMatcher"
    ; <add-import> "mb.resource.hierarchical.match.PathResourceMatcher"
    // Note: meaning of these ASTs:
    //   new PathResourceWalker(new NoHiddenPathMatcher())
    //   new PathResourceMatcher([matcher])

  // p2j-ast-filter: Pie filter -> (stmts, Java AST expression value)
  p2j-ast-filter:
    None() -> ([], Null())
  p2j-ast-filter:
    Some(FilterPart(Regex(exp))) -> <p2j-ast-filter-common> ("RegexPathMatcher", exp)
  p2j-ast-filter:
    Some(FilterPart(Pattern(exp))) -> <p2j-ast-filter-common> ("AntPatternPathMatcher", exp)
  p2j-ast-filter:
    Some(FilterPart(Patterns(exp))) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; patternsName       := <newname> "patterns"
    ; matchResultName    := <newname> "matchResult"
    ; stmts              := <concat> [expStmts,
        [ LocVarDeclStm(
            LocalVarDecl(
              [Final()]
            , ClassType(
                Id("ArrayList")
              , Some(TypeArguments([ClassType([], Id("AntPattern"), None())]))
              )
            , [ VariableDeclInit(
                  VariableDecl(Id(patternsName))
                , NewInstance(None(), [], Id("ArrayList"), [], Some(Diamond()), [])
                )
              ]
            )
          )
        , ForEach(
            []
          , ClassType(Id("String"), None())
          , VariableDecl(Id("pattern"))
          , expVal
          , Block(
              [ ExpressionStatement(
                  InvokeQExp(
                    ExpressionName(Id(patternsName))
                  , None()
                  , Id("add")
                  , [NewInstance(None(), [], Id("AntPattern"), [], None(), [ExpressionName(Id("pattern"))])]
                  )
                )
              ]
            )
          )
        , LocVarDeclStm(
            LocalVarDecl(
              [Final()]
            , ClassType(Id("AntPatternsPathMatcher"), None())
            , [ VariableDeclInit(
                  matchResultName
                , NewInstance(None(), [], Id("AntPatternsPathMatcher"), [], None(), [ExpressionName(Id(patternsName))])
                )
              ]
            )
          )
        ]
      ]
    // Note: meaning of this AST:
    //         final ArrayList<AntPattern> [patternsName] = new ArrayList<>();
    //         for(String pattern : [expVal]) {
    //             [patternsName].add(new AntPattern(pattern));
    //         }
    //         final AntPatternsPathMatcher [matcherResult] = new AntPatternsPathMatcher([patternsName]);
    ; expRes                := ExpressionName(Id(matchResultName))
    ; result                := (stmts, expRes)
    ; <add-import> "mb.resource.hierarchical.match.path.AntPatternsPathMatcher"
    ; <add-import> "mb.resource.util.AntPattern"
    ; <add-import> "java.util.ArrayList"
  p2j-ast-filter:
    Some(FilterPart(Extension(exp))) -> <p2j-ast-filter-common> ("ExtensionPathMatcher", exp)
  p2j-ast-filter:
    Some(FilterPart(Extensions(exp))) -> <p2j-ast-filter-common> ("ExtensionsPathMatcher", exp)

  // p2j-ast-filter-common: (Pie matcher, Pie exp) -> (stmts, Java AST expression value)
  p2j-ast-filter-common:
    (matcher, exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; resultExp          := NewInstance(None(), [], Id(matcher), [], None(), [expVal])
    // Note: meaning of this AST: new [matcher]([expVal])
    ; result                := (expStmts, resultExp)
    ; <add-import> $[mb.resource.hierarchical.match.path.[matcher]]


  p2j-ast-exp:
    r@ReadPath(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> r
    ; readResultName     := <newname> "readResult"
    ; stmts              := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(readResultName))
              , InvokeQExp(ExpressionName(Id("Util")), None(), Id("readToString"), [expVal])
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //       final [ty] [readResultName] = Util.readToString([expVal]);
      ]
    ; result             := (stmts, readResultName)

  p2j-ast-exp:
    e@ExistsPath(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> e
    ; existsResultName   := <newname> "existsResult"
    ; stmts              := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(existsResultName))
              , InvokeQExp(
                  InvokeQExp(ExpressionName(Id("Files")), None(), Id("exists"), [expVal])
                , None()
                , Id("getJavaPath")
                , []
                )
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //       final [ty] [existsResultName] = Files.exists([expStr].getJavaPath());
      ]
    ; result             := (stmts, existsResultName)

rules // Early return and failure

  p2j-ast-exp:
    Return(exp) -> result
    with
      (expStmts, expVal) := <p2j-ast-pie-func-impl-returnvalue> exp
    ; resultExp          := <Snd> <try-p2j-ast-exp> UnitLit()
    ; stmts              := <concat> [expStmts, [Return(expVal)]]
    ; result             := (stmts, resultExp)

  p2j-ast-exp:
    Fail(exp) -> result
    with
      <add-import> "mb.pie.api.ExecException"
    ; (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; stmts              := <concat> [
        expStmts
      , [ Throw(NewInstance(
            None()
          , []
          , Id("ExecException")
          , []
          , None()
          , [ InvokeQExp(expVal, None(), Id("toString"), [])]
          ))
        ]
        // Note: meaning of this AST: throw new ExecException([expVal].toString());
      ]
    ; resultExp          := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result             := (stmts, resultExp)

rules // Literals

  p2j-ast-exp: UnitLit()        -> ([], Field(ExpressionName(Id("None")), Id("instance")))
  p2j-ast-exp: BoolLit(True())  -> ([], NewInstance(None(), [], Id("Boolean"), [], None(), [True()]))
  p2j-ast-exp: BoolLit(False()) -> ([], NewInstance(None(), [], Id("Boolean"), [], None(), [False()]))
  p2j-ast-exp: IntLit(i)        -> ([], NewInstance(None(), [], Id("Integer"), [], None(), [Deci(i)]))
  p2j-ast-exp: NullLit()        -> ([], Null())


  p2j-ast-exp:
    TupleLit(exps) -> result
    with
      <add-import> "mb.pie.util.Util"
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := InvokeQExp(ExpressionName(Id("Util")), None(), Id("tuple"), expsVals)
      //  Note: meaning of this AST: Util.tuple([expsVals])
    ; result                := (stmts, exp)

  p2j-ast-exp:
    ListLit(exps) -> result
    with
      <add-import> "java.util.Arrays"
    ; <add-import> "java.util.ArrayList"
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := NewInstance(None(), [], Id("ArrayList"), [], Some(Diamond()), [
        InvokeQExp(ExpressionName(Id("Arrays")), None(), Id("asList"), expsVals)
      ])
    //  Note: meaning of this AST: new ArrayList<>(Arrays.asList([expsVals]))
    ; result                := (stmts, exp)

rules // Interpolated string literal

  p2j-ast-exp:
    StrLit([]) -> result
    with
      result := ([], StringLiteral($[""]))

  p2j-ast-exp:
    StrLit(parts@[first|rest]) -> result
    with
      (partsStmts, partsExps) := <unzip> <map(p2j-ast-strpart)> parts
    ; stmts                   := <concat> partsStmts
    ; exp                     := <fold-left(p2j-ast-add-strings)> partsExps
    ; result                  := (stmts, exp)

  // Replace all escaped \$ with $. Note: "\\$" because the \ needs to be escaped in stratego.
  p2j-ast-strpart:
    Str(chars) -> ([], StringLiteral($["[<string-replace(|"\\$", "$")> chars]"]))

  p2j-ast-strpart:
    StrInterpRef(refExp) -> result
    with
      (stmts, expVal) := <try-p2j-ast-exp> refExp
    ; resultVal       := InvokeQExp(
        ExpressionName(Id("String"))
      , None()
      , Id("valueOf")
      , [ expVal ]
      )
    ; result          := (stmts, resultVal)


  p2j-ast-strpart:
    StrInterpExp(exp) -> result
    with
      (stmts, expVal) := <try-p2j-ast-exp> exp
    ; resultVal       := InvokeQExp(
        ExpressionName(Id("String"))
      , None()
      , Id("valueOf")
      , [ expVal ]
      )
    ; result          := (stmts, resultVal)

  p2j-ast-add-strings:
    (e1, e2) -> Add(e1, e2)

rules // Interpolated path literal

  p2j-ast-exp:
    e@PathLit(prefix, parts) -> result
    with
      <add-import> "mb.resource.fs.FSPath"
    ; (partsStmts, partsExps) := <unzip> <map(p2j-ast-pathpart)> parts
    ; stmts                   := <concat> partsStmts
    ; exp                     := NewInstance(None(), [], Id("FSPath"), [], None(), [
        <fold-left(p2j-ast-add-strings)> [StringLiteral($["[prefix]"]) | partsExps]
      ])
      // Note: meaning of this AST: new FSPath("[prefix][partsStr]")
    ; result                      := (stmts, exp)

  p2j-ast-pathpart:
    Path(chars) -> ([], StringLiteral($["[<string-replace(|"\\$", "$")> chars]"]))

  p2j-ast-pathpart:
    PathInterpRef(refExp) -> <try-p2j-ast-exp> refExp

  p2j-ast-pathpart:
    PathInterpExp(exp) -> <try-p2j-ast-exp> exp
