module statics/func_def

imports

  signatures/constructors-sig
  signatures/pie-sig
  signatures/func_def-sig
  statics/base
  statics/type
  statics/common
  statics/func_body

rules

  funcDefOk : scope * FuncDef
  funcDefOk(s_mod, func@FuncDef(func_head, impl)) :- {name s_func out_ty impl_kind ty}
    typeOfFuncHead(s_mod, emptyScope(s_mod), func_head) == (s_func, name, ty@FuncType(_, out_ty)),
    declareFunc(s_mod, name, ty, impl_kind),
    declareLocalFunc(s_mod, name, ty),
    funcImplOk(s_func, impl, out_ty, name) == impl_kind,
    @func.kind := impl_kind,
    @func.type := ty.

  typeOfFuncHead : scope * scope * FuncHead -> (scope * string * TYPE)
  typeOfFuncHead(s, s_type_args, FuncHead(name, Params(params), out_ty_exp)) = (s_func, name, FuncType(param_tys, out_ty)) :-
    new s_func,
    s_func -P-> s,
    typeOfParams(s, s_type_args, s_func, params) == param_tys,
    typeOfWithTypeArgScope(s, s_type_args, out_ty_exp, TRUE()) == out_ty,
    try { out_ty != WildcardType(_, _) } | error $[Cannot use a wildcard as return type. Use its upper bound instead] @out_ty_exp.

  typeOfParam : scope * scope * scope * Param -> TYPE
  typeOfParams maps typeOfParam(*, *, *, list(*)) = list(*)

  typeOfParam(s_mod, s_type_args, _, Param(lexical_type)) = semantic_type :-
    typeOfWithTypeArgScope(s_mod, s_type_args, lexical_type, TRUE()) == semantic_type,
    try { semantic_type != WildcardType(_, _) } | error $[Cannot use a wildcard as parameter type. Use the upper bound of the wildcard instead] @lexical_type.

  typeOfParam(s_mod, s_type_args, s_func, p@NParam(name, lexical_type)) = semantic_type :-
    typeOfWithTypeArgScope(s_mod, s_type_args, lexical_type, TRUE()) == semantic_type,
    declareVal(s_func, name, semantic_type, InputValKind()),
    try { semantic_type != WildcardType(_, _) } | error $[Cannot use a wildcard as parameter type. Use the upper bound of the wildcard instead] @lexical_type.

  funcImplOk : scope * FuncImpl * TYPE * FUNCID -> FuncImplKind
  funcImplOk(_, PieForeignFuncImpl(class_id), _, name) = PieForeignFuncKind() :-
    @name.javaClassId := class_id.
  funcImplOk(_, JavaForeignFuncImpl(class_id, java_name), _, name) = JavaForeignFuncKind() :-
    @name.javaClassId := class_id,
    @name.javaMethodId := java_name.
  funcImplOk(_, JavaForeignConstructorImpl(class_id), _, name) = JavaForeignConstructorKind() :-
    @name.javaClassId := class_id.
  funcImplOk(s_func_outer, PieFuncImpl(Exp2PieFuncBody(exp), keyFunc), expected_type, _) = PieFuncKind() :- {s_func_inner}
    new s_func_inner,
    s_func_inner -P-> s_func_outer,
    setContext(s_func_inner, "func_return_type", ContextType(expected_type)),
    expectAssignableTo(s_func_inner, exp, expected_type) == _,
    optionalKeyFuncOk(s_func_outer, keyFunc).

  keyFuncOk : scope * PieKeyFunc
  optionalKeyFuncOk maps keyFuncOk(*, list(*))

  keyFuncOk(s_func_outer, PieKeyFunc(Exp2PieFuncBody(exp))) :- {s_keyfunc}
    new s_keyfunc,
    s_keyfunc -P-> s_func_outer,
    typeOfExp(s_keyfunc, exp) == _.
