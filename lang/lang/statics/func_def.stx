module statics/func_def

imports

  signatures/constructors-sig
  signatures/pie-sig
  signatures/func_def-sig
  statics/base
  statics/type
  statics/type_common
  statics/common
  statics/func_body

rules

  funcDefOk : scope * FuncDef
  funcDefOk(s_mod, func@FuncDef(func_head@FuncHead(_, type_params, _, _), impl)) :-
    {name s_func out_ty impl_kind ty}
    typeOfFuncHead(s_mod, s_mod, func_head, impl_kind) == (s_func, name, ty@FuncDefType(_, _, out_ty)),
    declareFunc(s_mod, name, (s_func, ty), impl_kind),
    declareLocalFunc(s_mod, name, (s_func, ty)),
    funcImplOk(s_func, impl, type_params, out_ty, name) == impl_kind,
    @func.kind := impl_kind,
    @func.type := ty.

  typeOfFuncHead : scope * scope * FuncHead * FuncImplKind -> (scope * string * TYPE)
  typeOfFuncHead(s, s_parent, FuncHead(name, type_params, Params(params), out_ty_exp), impl_kind) =
    (s_func, name, FuncDefType(type_param_tys, param_tys, out_ty))
  :-
    new s_func,
    s_func -P-> s_parent,
    typesOfTypeParams(s, s_func, type_params) == type_param_tys,
    typeOfParams(s, s_func, s_func, params, InputValKind(), impl_kind) == param_tys,
    typeOf(s, s_func, out_ty_exp, FALSE(), []) == out_ty,
    try { out_ty != WildcardType(_, _, _) } | error $[Cannot use a wildcard as return type. Use its upper bound instead] @out_ty_exp.

  typeOfParam : scope * scope * scope * Param * ValKind * FuncImplKind -> TYPE
  typeOfParams maps typeOfParam(*, *, *, list(*), *, *) = list(*)

  typeOfParam(s_mod, s_type_args, _, Param(lexical_type), _, _) = semantic_type :-
    typeOf(s_mod, s_type_args, lexical_type, FALSE(), []) == semantic_type,
    try { semantic_type != WildcardType(_, _, _) } | error $[Cannot use a wildcard as parameter type. Use the upper bound of the wildcard instead] @lexical_type.

  typeOfParam(s_mod, s_type_args, s_func, NParam(value_id, lexical_type), val_kind, impl_kind) = semantic_type :-
    typeOf(s_mod, s_type_args, lexical_type, FALSE(), []) == semantic_type,
    declareValIfNotAnonymous(s_func, value_id, semantic_type, val_kind) == _,
    funcParamValueIdOk(value_id, impl_kind, lexical_type),
    try { semantic_type != WildcardType(_, _, _) } | error $[Cannot use a wildcard as parameter type. Use the upper bound of the wildcard instead] @lexical_type.

    funcParamValueIdOk : ValueId * FuncImplKind * Type
    funcParamValueIdOk(ValueId(_), _, _).
    funcParamValueIdOk(value_id@AnonymousValue(), impl_kind, lexical_type) :-
      try {impl_kind != PieFuncKind()} | note $[Anonymous parameter _ cannot be referred to but will be included in the generated task signature. If this is not required, this parameter can be removed. If this is intended, it is recommended to add a comment explaining why this is necessary. To refer to this parameter, use a different name.] @value_id,
      try {orB(notB(funcImplIsForeign(impl_kind)), typeIsQualified(lexical_type)) == TRUE()}
        | warning $[Anonymous parameter name can be omitted. Alternatively, the parameter can have a proper name.] @value_id.

      funcImplIsForeign : FuncImplKind -> BOOLEAN
      funcImplIsForeign(JavaForeignFuncKind()) = TRUE().
      funcImplIsForeign(JavaForeignConstructorKind()) = TRUE().
      funcImplIsForeign(JavaForeignMethodKind()) = TRUE().
      funcImplIsForeign(PieForeignFuncKind()) = TRUE().
      funcImplIsForeign(PieFuncKind()) = FALSE().
      funcImplIsForeign(PieBuiltInFuncKind(_)) = FALSE().

      typeIsQualified : Type -> BOOLEAN
      typeIsQualified(DataTy2Type(DataTy(ModuleList(_), _, _))) = TRUE().
      typeIsQualified(_) = FALSE().


  funcImplOk : scope * FuncImpl * TypeParams * TYPE * FUNCID -> FuncImplKind
  funcImplOk(_, PieForeignFuncImpl(class_id), _, _, name) = PieForeignFuncKind() :-
    @name.javaClassId := class_id.
  funcImplOk(_, JavaForeignFuncImpl(class_id, java_name), _, _, name) = JavaForeignFuncKind() :-
    @name.javaClassId := class_id,
    @name.javaMethodId := java_name.
  funcImplOk(_, JavaForeignConstructorImpl(class_id), _, _, name) = JavaForeignConstructorKind() :-
    @name.javaClassId := class_id.
  funcImplOk(s_func_outer, PieFuncImpl(injections, Exp2PieFuncBody(exp), keyFunc), type_params, expected_type, name) = PieFuncKind() :-
    {s_func_inner s_injections}
    new s_func_inner,
    s_func_inner -P-> s_func_outer,
    setContext(s_func_inner, "func_return_type", ContextType(expected_type)),
    injectionsOk(s_func_inner, injections) == s_injections,
    expectAssignableTo(s_injections, exp, instantiateTypeArgs(s_func_inner, expected_type), ExpressionKind()) == _,
    optionalKeyFuncOk(s_func_outer, keyFunc),
    // See https://github.com/MeAmAnUsername/pie/issues/181
    try { getTypeParamsList(type_params) == [] } | error $[Code generation for PIE tasks with type parameters has not been implemented yet. Implement this task in Java and import it as foreign [name] instead] @type_params.

  injectionsOk : scope * PieFuncInjections -> scope
  injectionsOk(s_func, NoInjections()) = s_func.
  injectionsOk(s_func, inj@Injections(Params(params))) = s_injections :-
    new s_injections,
    s_injections -P-> s_func,
    typeOfParams(s_func, s_injections, s_injections, params, InjectedValKind(), PieFuncKind()) == _,
    try { params != [] } | warning $[Empty injections are useless and can be omitted] @inj,
    warnForUnnamedInjections(params).

    warnForUnnamedInjection : Param
    warnForUnnamedInjections maps warnForUnnamedInjection(list(*))
    warnForUnnamedInjection(p@Param(_)) :-
      false | error $[Injections must be named. This injection must be named or removed.] @p.
    warnForUnnamedInjection(NParam(_, _)).

  keyFuncOk : scope * PieKeyFunc
  optionalKeyFuncOk maps keyFuncOk(*, list(*))

  keyFuncOk(s_func_outer, PieKeyFunc(Exp2PieFuncBody(exp))) :- {s_keyfunc}
    new s_keyfunc,
    s_keyfunc -P-> s_func_outer,
    typeOfExp(s_keyfunc, exp) == _.
