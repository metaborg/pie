module statics/type_common

imports

  signatures/constructors-sig
  statics/base
  statics/type
  statics/common

rules

  /**
   * genericParamsOk(s, s_data_def, GenericParams(params))
   * todo
   */
  genericParamsOk : scope * scope * GenericParams -> list(GenericParamType)
  genericParamsOk(s, s_def, GenericParams(params)) = wrapBounds(parameters) :-
    typeOfgenericParams(s, s_def, params) == parameters,
    !generic_params[parameters] in s_def.
    
    wrapBound : (GenericParameter * TYPE * TYPE) -> GenericParamType
    wrapBounds maps wrapBound(list(*)) = list(*)
    wrapBound((GenericParameter(_, name), upper_bound, lower_bound)) =
      GenericParamType(name, typeToUpperBoundType(upper_bound), typeToLowerBoundType(lower_bound)).

    typeOfgenericParam : scope * scope * GenericParam -> (GenericParameter * TYPE * TYPE)
    typeOfgenericParams maps typeOfgenericParam(*, *, list(*)) = list(*)
    typeOfgenericParam(s, s_def, GenericParam(name, upper_bound, lower_bound)) = (param, upper_bound_ty, lower_bound_ty) :-
      {upper_error_node lower_error_node}
      bothBoundsOk(upper_bound, lower_bound),
      typeOrTopType(typeOfUpperBound(s, s_def, upper_bound, FALSE())) == upper_bound_ty,
      typeOrBottomType(typeOfLowerBound(s, s_def, lower_bound, FALSE())) == lower_bound_ty,
      declareGenericParam(s_def, name, upper_bound_ty, lower_bound_ty) == param,
      try { resolveData(s, name) == [] } | note $[Generic parameter [name] shadows data type [name]] @name.

      bothBoundsOk : UpperBound * LowerBound
      bothBoundsOk(_, _).
      bothBoundsOk(u@UpperBound(_), l@LowerBound(_)) :-
        false | error $[Cannot have both an upper and lower bound] @u,
        false | error $[Cannot have both an upper and lower bound] @l.

      typeOfUpperBound : scope * scope * UpperBound * BOOLEAN -> UpperBoundType
      typeOfUpperBound(_, _, NoUpperBound(), _) = NoUpperBoundType().
      typeOfUpperBound(s, s_type_args, UpperBound(upper_bound), resolve_in_super_types) =
        UpperBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, upper_bound, resolve_in_super_types))
      :-
        try { ty != WildcardType(_, _) } | error $[Cannot use wildcard as upper bound] @upper_bound,
        try { ty != UnitType()   } | warning $[Nonsensical bound: unit does not have subtypes] @upper_bound,
        try { ty != ListType(_)  } | warning $[Nonsensical bound: list types do not have subtypes] @upper_bound,
        try { ty != TupleType(_) } | warning $[Nonsensical bound: tuple types do not have subtypes] @upper_bound,
        try { ty != BottomType() } | warning $[Nonsensical bound: BOTTOM is the only matching type] @upper_bound.

      typeOfLowerBound : scope * scope * LowerBound * BOOLEAN -> LowerBoundType
      typeOfLowerBound(_, _, NoLowerBound(), _) = NoLowerBoundType().
      typeOfLowerBound(s, s_type_args, LowerBound(lower_bound), resolve_in_super_types) =
        LowerBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, lower_bound, resolve_in_super_types))
      :-
        try { ty != WildcardType(_, _) } | error $[Cannot use wildcard as lower bound] @lower_bound,
        try { ty != TopType() } | warning $[Nonsensical bound: TOP is the only matching type] @lower_bound.

  /**
   * getScopeFromType(s, ty)
   * Returns the scope with methods associated with type [ty]
   */
  getScopeFromType : scope * TYPE -> scope
  getScopeFromType(_, DataType(s_data)) = s_data.
  getScopeFromType(s, ty) = emptyScope(s).

  /**
   * typeOrTopType(upper_bound) = ty
   * Get the type from an explicit upper bound or the top type if there is no
   * upper bound.
   */
  typeOrTopType : UpperBoundType -> TYPE
  typeOrTopType(NoUpperBoundType()) = TopType().
  typeOrTopType(UpperBoundType(ty)) = ty.

  /**
   * typeOrBottomType(lower_bound) = ty
   * Get the type from an explicit lower bound or the bottom type if there is
   * no lower bound.
   */
  typeOrBottomType : LowerBoundType -> TYPE
  typeOrBottomType(NoLowerBoundType()) = BottomType().
  typeOrBottomType(LowerBoundType(ty)) = ty.

  /**
   * typeToUpperBoundType(ty) = upper_bount_type
   * Returns NoUpperBoundType for TopType, otherwise ty wrapped in
   * UpperBoundType.
   */
  typeToUpperBoundType : TYPE -> UpperBoundType
  typeToUpperBoundType(TopType()) = NoUpperBoundType().
  typeToUpperBoundType(ty) = UpperBoundType(ty).

  /**
   * typeToLowerBoundType(ty) = lower_bount_type
   * Returns NoLowerBoundType for BottomType, otherwise ty wrapped in
   * LowerBoundType.
   */
  typeToLowerBoundType : TYPE -> LowerBoundType
  typeToLowerBoundType(BottomType()) = NoLowerBoundType().
  typeToLowerBoundType(ty) = LowerBoundType(ty).

  /**
   * getBounds(T) -> (upper_bound, lower_bound)
   * Gets the upper and lower bound of a type [T]. The bounds for generic
   * parameters and wildcards are taken as is, for other types the bounds are
   * simply that same type.
   */
  getBounds : TYPE -> (TYPE * TYPE)
  getBounds(WildcardType(ub, lb)) = (typeOrTopType(ub), typeOrBottomType(lb)).
  getBounds(GenericParameter2TYPE(GenericParameter(s, name))) = (ub, lb) :-
    resolveGenericParam(s, name) == [(_, (_, (ub, lb)))] | error $[BUG: not a single declaration of [name] in [s]].
  getBounds(T) = (T, T).


  /**
   * getTypeArgsList(type_args) = type_args_list
   * Gets the list of type arguments from a TypeArgs.
   * Returns an empty list for NoTypeArgs().
   */
  getTypeArgsList : TypeArgs -> list(Type)
  getTypeArgsList(NoTypeArgs()) = [].
  getTypeArgsList(TypeArgs(type_args)) = type_args.

  /**
   * findGenericDef(s_data) -> s_data_def
   * Finds the generic definition of a data type [s_data].
   * [s_data] can be a generic definition, in which case it itself will be
   * returned.
   */
  // Get generic definition of s_data. s_data can be either an instance or the generic def itself.
  findGenericDef : scope -> scope
  findGenericDef(s_data) = getScope(occ) :-
    query () filter P? min P < $ in s_data |-> [occ].

  /**
   * getGenericDef(s_data_instance) -> s_data_def
   * Gets the generic definition of a data type instance [s_data_instance].
   * [s_data_instance] cannot be a generic definition, it must be an instance.
   */
  getGenericDef : scope -> scope
  getGenericDef(s_data_instance) = getScope(occ) :-
    query () filter P in s_data_instance |-> [occ].

  /**
   * getTypeArgs(s_data) = type_args
   * Get all type arguments defined in s_data.
   * Does not follow any edges.
   */
  getTypeArgs : scope -> list((GenericParameter * TYPE))
  getTypeArgs(s_data) = getArgTypes(occs) :-
    query generic_arg filter e in s_data |-> occs.

    getArgType : (path * (GenericParameter * TYPE)) -> (GenericParameter * TYPE)
    getArgTypes maps getArgType(list(*)) = list(*)
    getArgType((path, arg_ty)) = arg_ty.

  /**
   * getTypeArgType(type_arg) -> type
   * Gets the type of a type argument, i.e. the type that the type parameter is
   * bound to by this type argument.
   */
  getTypeArgType : (GenericParameter * TYPE) -> TYPE
  getTypeArgTypes maps getTypeArgType(list(*)) = list(*)
  getTypeArgType((_, ty)) = ty.

  /**
   * renameAll(s_pre_existing, s_type_params1, type_params1, s_type_params2,
   *   type_params2) = s_renaming
   * Renames all type parameters from [type_params1] to [type_params2]
   * Renamings are returned as the scope [s_renaming]
   * Overrides the renamings from [s_pre_existing], but type parameters from
   * [s_pre_existing] that are not a type parameter in [type_params1] keep
   * their original value.
   * [s_type_params1] and [s_type_params2] are the scopes for the type
   * parameters of [type_params1] and [type_params2] respectively.
   * Fails without message when [type_params1] and [type_params2] have
   * different lengths.
   */
  renameAll : scope * scope * list(GenericParamType) * scope * list(GenericParamType) -> scope
  renameAll(s_pre_existing, s_type_params1, type_params1, s_type_params2, type_params2) = s_renaming :-
    new s_renaming,
    s_renaming -P-> s_pre_existing,
    renameAll_1(s_renaming, s_type_params1, type_params1, s_type_params2, type_params2).

    rename : scope * scope * GenericParamType * scope * GenericParamType
    renameAll_1 maps rename(*, *, list(*), *, list(*))
    rename(s, s_param1, GenericParamType(name1, _, _), s_param2, GenericParamType(name2, _, _)) :-
      {type}
      type == GenericParameter2TYPE(GenericParameter(s_param2, name2)),
      declareTypeArg(s, GenericParameter(s_param1, name1), type).

  /**
   * typeListsLengthsEqual(Ts1, Ts2) = equal_lengths
   * Checks if the length of the two lists is equal
   */
  typeListsLengthsEqual : list(TYPE) * list(TYPE) -> BOOLEAN
  typeListsLengthsEqual([], []) = TRUE().
  typeListsLengthsEqual([_|_], []) = FALSE().
  typeListsLengthsEqual([], [_|_]) = FALSE().
  typeListsLengthsEqual([_|Ts1], [_|Ts2]) =
    typeListsLengthsEqual(Ts1, Ts2).

  /**
   * ppTYPE(type) -> name
   * get the name of a type
   * Does not work with composite types, only use for debugging!
   */
  ppTYPE : TYPE -> string
  ppTYPEs maps ppTYPE(list(*)) = list(*)
  ppTYPES maps ppTYPE(list(*)) = list(*)
  ppTYPE(UnitType()) = "unit".
  ppTYPE(BoolType()) = "bool".
  ppTYPE(IntType()) = "int".
  ppTYPE(StrType()) = "string".
  ppTYPE(PathType()) = "path".
  ppTYPE(NullType()) = "null".
  ppTYPE(TopType()) = "top".
  ppTYPE(BottomType()) = "bottom".
  ppTYPE(NullableType(T)) = "nullable".
  ppTYPE(ListType(T)) = "list".
  ppTYPE(EmptyListType()) = "[]".
  ppTYPE(TupleType(Ts)) = "tuple".
  ppTYPE(SupplierType(T)) = "supplier".
  ppTYPE(FuncType(type_params, in, out)) = "func".
  ppTYPE(DataType(s_data)) = name :- getContext(s_data, "data_name_unqualified") == ContextName(name).
  ppTYPE(WildcardType(ub, lb)) = "wildcard".
  ppTYPE(GenericParameter2TYPE(GenericParameter(_, name))) = name.

  /**
   * ppScope(s) -> name
   * get the name of a scope
   * returns "unknown scope" if it is not a type.
   */
  ppScope : scope -> string
  ppScope(s) = ppScope_1(s, occs) :-
    query context
      filter P*
         and {name :- "data_name_unqualified" == name}
         min $ < P
         and {x1, x2 :- x1 == x2}
          in s |-> occs.

    ppScope_1 : scope * list((path * (string * CONTEXT))) -> string
    ppScope_1(s, []) = "unknown scope".
    ppScope_1(_, [(_, (_, ContextName(name)))]) = name.
    ppScope_1(s, [_,_|_]) = "unknown scope" :- false | error $[BUG: resolved multiple context values for "data_name_unqualified" in [s]].
