module statics/type_common

imports

  signatures/constructors-sig
  statics/base
  statics/type
  statics/common

rules

  /**
   * Returns the first element in the list that is TRUE(), or the default otherwise.
   */
  firstTrueT : list((BOOLEAN * TYPE)) * TYPE -> TYPE
  firstTrueT([], T) = T.
  firstTrueT([(FALSE(), _)|rest], T) = firstTrueT(rest, T).
  firstTrueT([(TRUE(), T)|_], _) = T.

  /**
   * makeNullable(T)
   * Make Type [T] nullable if it is not already.
   * This returns NullType() or TopType() if [T] already was one of those and
   * NullableType(_) otherwise
   */
  makeNullable : TYPE -> TYPE
  makeNullable(NullType()) = NullType().
  makeNullable(T@NullableType(_)) = T.
  makeNullable(TopType()) = TopType().
  makeNullable(T) = NullableType(T).

  /**
   * getScopeFromType(s, ty)
   * Returns the scope with methods associated with type [ty]
   */
  getScopeFromType : scope * TYPE -> scope
  getScopeFromType(_, DataType(s_data)) = s_data.
  getScopeFromType(s, ty) = emptyScope(s).

  /**
   * typeOrTopType(upper_bound) = ty
   * Get the type from an explicit upper bound or the top type if there is no
   * upper bound.
   */
  typeOrTopType : UpperBoundType -> TYPE
  typeOrTopType(NoUpperBoundType()) = TopType().
  typeOrTopType(UpperBoundType(ty)) = ty.

  /**
   * typeOrBottomType(lower_bound) = ty
   * Get the type from an explicit lower bound or the bottom type if there is
   * no lower bound.
   */
  typeOrBottomType : LowerBoundType -> TYPE
  typeOrBottomType(NoLowerBoundType()) = BottomType().
  typeOrBottomType(LowerBoundType(ty)) = ty.

  /**
   * typeToUpperBoundType(ty) = upper_bount_type
   * Returns NoUpperBoundType for TopType, otherwise ty wrapped in
   * UpperBoundType.
   */
  typeToUpperBoundType : TYPE -> UpperBoundType
  typeToUpperBoundType(TopType()) = NoUpperBoundType().
  typeToUpperBoundType(ty) = UpperBoundType(ty).

  /**
   * typeToLowerBoundType(ty) = lower_bount_type
   * Returns NoLowerBoundType for BottomType, otherwise ty wrapped in
   * LowerBoundType.
   */
  typeToLowerBoundType : TYPE -> LowerBoundType
  typeToLowerBoundType(BottomType()) = NoLowerBoundType().
  typeToLowerBoundType(ty) = LowerBoundType(ty).

  /**
   * getBounds(T) -> (upper_bound, lower_bound)
   * Gets the upper and lower bound of a type [T]. The bounds for generic
   * parameters and wildcards are taken as is, for other types the bounds are
   * simply that same type.
   */
  getBounds : TYPE -> (TYPE * TYPE)
  getBounds(WildcardType(ub, lb, _)) = (typeOrTopType(ub), typeOrBottomType(lb)).
  getBounds(GenericParameter2TYPE(GenericParameter(s, name))) = (ub, lb) :-
    resolveGenericParam(s, name) == [(_, (_, (ub, lb)))] | error $[BUG: not a single declaration of [name] in [s]].
  getBounds(T) = (T, T).


  /**
   * withinBounds((ub1, lb1), (ub2, lb2), assignable_kind) = within_bounds
   * Returns TRUE iff the upper bound [ub1] is assignable to upper bound [ub2]
   * and lower bound [lb2] is assignable to lower bound [lb1].
   * Uses [assignable_kind] to compare bounds.
   */
  withinBounds : (TYPE * TYPE) * (TYPE * TYPE) * AssignableKind -> BOOLEAN
  withinBounds((ub1, lb1), (ub2, lb2), assignable_kind) =
    andB(isAssignableTo(ub1, ub2, assignable_kind), isAssignableTo(lb2, lb1, assignable_kind)).

  /**
   * getTypeParamsList(type_params) = type_params_list
   * Gets the list of type parameters from a GenericParams.
   * Returns an empty list for NoGenericParams().
   */
  getTypeParamsList : GenericParams -> list(GenericParam)
  getTypeParamsList(NoGenericParams()) = [].
  getTypeParamsList(GenericParams(type_params)) = type_params.

  /**
   * getTypeArgsList(type_args) = type_args_list
   * Gets the list of type arguments from a TypeArgs.
   * Returns an empty list for NoTypeArgs().
   */
  getTypeArgsList : TypeArgs -> list(Type)
  getTypeArgsList(NoTypeArgs()) = [].
  getTypeArgsList(TypeArgs(type_args)) = type_args.

  /**
   * findGenericDef(s_data) -> s_data_def
   * Finds the generic definition of a data type [s_data].
   * [s_data] can be a generic definition, in which case it itself will be
   * returned.
   */
  // Get generic definition of s_data. s_data can be either an instance or the generic def itself.
  findGenericDef : scope -> scope
  findGenericDef(s_data) = getScope(occ) :-
    query () filter P? min P < $ in s_data |-> [occ].

  /**
   * getGenericDef(s_data_instance) -> s_data_def
   * Gets the generic definition of a data type instance [s_data_instance].
   * [s_data_instance] cannot be a generic definition, it must be an instance.
   */
  getGenericDef : scope -> scope
  getGenericDef(s_data_instance) = getScope(occ) :-
    query () filter P in s_data_instance |-> [occ].

  /**
   * getTypeArgsUnordered(s_data) = type_args
   * Get all type arguments defined in s_data.
   * Type arguments are not ordered.
   * Does not follow any edges.
   */
  getTypeArgsUnordered : scope -> list((GenericParameter * TYPE))
  getTypeArgsUnordered(s_data) = getArgTypes(occs) :-
    query generic_arg filter e in s_data |-> occs.

    getArgType : (path * (GenericParameter * TYPE)) -> (GenericParameter * TYPE)
    getArgTypes maps getArgType(list(*)) = list(*)
    getArgType((path, arg_ty)) = arg_ty.

  /**
   * getTypeArgsOrdered(s_data_instance) = type_args
   * Gets the type arguments in the same order as defined by the type
   * parameters.
   * Does not follow any edges.
   */
  getTypeArgsOrdered : scope -> list((GenericParameter * TYPE))
  getTypeArgsOrdered(s_data_instance) =
    getTypeArgsOrdered_1s(s_data_instance, tmp1@getGenericParams(s_data_instance)) :-
      try{false}|note$[DEBUG: getTypeArgsOrdered - s_data_instance: [s_data_instance], params: [tmp1]].

    getTypeArgsOrdered_1 : scope * (GenericParameter * TYPE * TYPE) -> (GenericParameter * TYPE)
    getTypeArgsOrdered_1s maps getTypeArgsOrdered_1(*, list(*)) = list(*)
    getTypeArgsOrdered_1(s_data, (param, _, _)) =
      (param, getTypeArgsOrdered_2(s_data, param, occs)) :-
      query generic_arg
        filter e
           and { param' :- param' == param }
            in s_data |-> occs.

    getTypeArgsOrdered_2 : scope * GenericParameter * list((path * (GenericParameter * TYPE))) -> TYPE
    getTypeArgsOrdered_2(s_data, param, []) = upper_bound :-
      getBounds(GenericParameter2TYPE(param)) == (upper_bound, _),
      false | error $[BUG: no generic parameters found from [s_data]].
    getTypeArgsOrdered_2(s_data, _, [(_, (param, val))]) = val.
    getTypeArgsOrdered_2(s_data, param, [_,_|_]) = upper_bound :-
      getBounds(GenericParameter2TYPE(param)) == (upper_bound, _),
      false | error $[BUG: multiple declarations for generic parameters found from [s_data]].

  /**
   * getTypeArgType(type_arg) -> type
   * Gets the type of a type argument, i.e. the type that the type parameter is
   * bound to by this type argument.
   */
  getTypeArgType : (GenericParameter * TYPE) -> TYPE
  getTypeArgTypes maps getTypeArgType(list(*)) = list(*)
  getTypeArgType((_, ty)) = ty.

  /**
   * renameAll(s_pre_existing, s_type_params1, type_params1, s_type_params2,
   *   type_params2) = s_renaming
   * Renames all type parameters from [type_params1] to [type_params2]
   * Renamings are returned as the scope [s_renaming]
   * Overrides the renamings from [s_pre_existing], but type parameters from
   * [s_pre_existing] that are not a type parameter in [type_params1] keep
   * their original value.
   * [s_type_params1] and [s_type_params2] are the scopes for the type
   * parameters of [type_params1] and [type_params2] respectively.
   * Fails without message when [type_params1] and [type_params2] have
   * different lengths.
   */
  renameAll : scope * scope * list(GenericParamType) * scope * list(GenericParamType) -> scope
  renameAll(s_pre_existing, s_type_params1, type_params1, s_type_params2, type_params2) = s_renaming :-
    new s_renaming,
    s_renaming -P-> s_pre_existing,
    renameAll_1(s_renaming, s_type_params1, type_params1, s_type_params2, type_params2).

    rename : scope * scope * GenericParamType * scope * GenericParamType
    renameAll_1 maps rename(*, *, list(*), *, list(*))
    rename(s, s_param1, GenericParamType(name1, _, _), s_param2, GenericParamType(name2, _, _)) :-
      {type}
      type == GenericParameter2TYPE(GenericParameter(s_param2, name2)),
      declareTypeArg(s, GenericParameter(s_param1, name1), type).

  /**
   * typeListsLengthsEqual(Ts1, Ts2) = equal_lengths
   * Checks if the length of the two lists is equal
   */
  typeListsLengthsEqual : list(TYPE) * list(TYPE) -> BOOLEAN
  typeListsLengthsEqual([], []) = TRUE().
  typeListsLengthsEqual([_|_], []) = FALSE().
  typeListsLengthsEqual([], [_|_]) = FALSE().
  typeListsLengthsEqual([_|Ts1], [_|Ts2]) =
    typeListsLengthsEqual(Ts1, Ts2).

  /**
   * ppTYPE(type) -> name
   * get the name of a type
   * Does not work with composite types, only use for debugging!
   */
  ppTYPE : TYPE -> string
  ppTYPEs maps ppTYPE(list(*)) = list(*)
  ppTYPES maps ppTYPE(list(*)) = list(*)
  ppTYPE(UnitType()) = "unit".
  ppTYPE(BoolType()) = "bool".
  ppTYPE(IntType()) = "int".
  ppTYPE(StrType()) = "string".
  ppTYPE(PathType()) = "path".
  ppTYPE(NullType()) = "null".
  ppTYPE(TopType()) = "top".
  ppTYPE(BottomType()) = "bottom".
  ppTYPE(NullableType(T)) = "nullable".
  ppTYPE(ListType(T)) = "list".
  ppTYPE(EmptyListType()) = "[]".
  ppTYPE(TupleType(Ts)) = "tuple".
  ppTYPE(SupplierType(T)) = "supplier".
  ppTYPE(FuncDefType(type_params, in, out)) = "func def".
  ppTYPE(FuncRefType(type_params, in, out)) = "func ref".
  ppTYPE(DataType(s_data)) = name :- getContext(s_data, "data_name_unqualified") == ContextName(name).
  ppTYPE(WildcardType(ub, lb, Free())) = "wildcard (capture state: free)".
  ppTYPE(WildcardType(ub, lb, Bound())) = "wildcard (capture state: bound)".
  ppTYPE(GenericParameter2TYPE(GenericParameter(_, name))) = name.

  /**
   * ppScope(s) -> name
   * get the name of a scope
   * returns "unknown scope" if it is not a type.
   */
  ppScope : scope -> string
  ppScope(s) = ppScope_1(s, occs) :-
    query context
      filter P*
         and {name :- "data_name_unqualified" == name}
         min $ < P
         and {x1, x2 :- x1 == x2}
          in s |-> occs.

    ppScope_1 : scope * list((path * (string * CONTEXT))) -> string
    ppScope_1(s, []) = "unknown scope".
    ppScope_1(_, [(_, (_, ContextName(name)))]) = name.
    ppScope_1(s, [_,_|_]) = "unknown scope" :- false | error $[BUG: resolved multiple context values for "data_name_unqualified" in [s]].
