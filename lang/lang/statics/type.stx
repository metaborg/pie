module statics/type

imports

  signatures/constructors-sig
  signatures/data-sig
  signatures/type-sig
  statics/base
  statics/common
  statics/type_common
  statics/module

rules // operations on types

  /**
   * inherits(s_sub, s_super) -> res
   * Returns TRUE() if s_sub inherits from (can be reached by only following
   * INHERIT|P edges from) s_super or is equal to s_super, FALSE() otherwise.
   */
  inherits : scope * scope -> BOOLEAN
  inherits(s_sub, s_super) = inherits_1(paths) :-
    query () filter P? (INHERIT P)* INHERIT? and { s_data :- s_data == s_super } in s_sub |-> paths.

    inherits_1 : list((path * scope)) -> BOOLEAN
    inherits_1([]) = FALSE().
    inherits_1([_|_]) = TRUE().

  /**
   * assignableTo(T1, T2, assignableKind)
   * Checks if an expression of type [T1] can be assigned to a variable of type [T2].
   * Holds if type T1 is a non-strict subtype of type T2.
   * Fails with error if T1 is not a subtype of T2.
   */
  assignableTo : TYPE * TYPE * AssignableKind
  assignableTo(T1, T2, assignableKind) :-
    isAssignableTo(T1, T2, assignableKind) == TRUE().

signature
  sorts AssignableKind constructors
    InvariantKind : AssignableKind
    TypeArgKind : AssignableKind
    ArgumentKind : AssignableKind // todo: can merge with ExpressionKind?
    ExpressionKind : AssignableKind

rules

  /**
   * isAssignableTo(T1, T2, assignableKind) = res
   * Checks if an expression of type [T1] can be assigned to a variable of type [T2].
   * todo: update
   * Returns TRUE() if:
   * - type T1 is a non-strict subtype of type T2
   * - T1 is a wildcard and its upper bound can be assigned to T2
   * - T2 is a wildcard and T1 can be assigned to the lower bound of T2
   * returns FALSE() otherwise.
   * May fail on unbound variables.
   */
  isAssignableTo : TYPE * TYPE * AssignableKind -> BOOLEAN
  isAssignableTo(NullType(), NullableType(_), _) = TRUE().
  isAssignableTo(T1, NullableType(T2), assignableKind) =
    isAssignableTo(T1, T2, assignableKind).
  isAssignableTo(NullableType(T1), NullableType(T2), assignableKind) =
    isAssignableTo(T1, T2, assignableKind).
  isAssignableTo(EmptyListType(), ListType(_), assignableKind) = TRUE().
  isAssignableTo(DataType(s_sub), DataType(s_super), assignableKind) =
    out@isAssignableTo_dataTypes(s_sub, s_super, inherits, type_args, s_super_def, assignableKind)
  :-
    {tmp1 tmp2}
    tmp1 == ppScope(s_sub),
    tmp2 == ppScope(s_super),
    try{false}|note$[DEBUG - [tmp1] is assignable to [tmp2] == [out] == isAssignableTo_dataTypes([s_sub], [s_super], [inherits], [type_args], [s_super_def], [assignableKind])],
    findGenericDef(s_super) == s_super_def,
    inherits(s_sub, s_super_def) == inherits,
    getTypeArgs(s_super) == type_args.

    /*
     * Explanation of implementation
     * 1. Make sure that they could be subtypes: if !inherits(s_sub, findGenericDef(s_super)) then FALSE()
     * 2. If s_super is a definition, s_sub is a subtype by definition: if getTypeArgs(s_super) == [] then TRUE()
     * 3. Else: s_super is an instance. Find s_super_def by following P edge: getGenericDef(s_super) == s_super_def
     *    [note] s_sub is either an instance of s_super_def, or an instance or generic def of a strict subtype of s_super_def.
     * 4. Get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def:
     *    query ()
     *      filter INHERIT? (P INHERIT)*
     *         and { s :- getGenericDef(s) == s_super_def }
     *          in s_sub |-> [(_, s_sub_super_instance)]
     * 5. Check if instances are compatible: isTypeArgsCompatible(s_sub_super_instance, s_super)
     */
    isAssignableTo_dataTypes : scope * scope * BOOLEAN * list((GenericParameter * TYPE)) * scope * AssignableKind -> BOOLEAN
    isAssignableTo_dataTypes(s_data, s_data, TRUE(), _, _, _) = TRUE(). // optimization: s_sub == s_super
    isAssignableTo_dataTypes(_, _, FALSE(), _, _, _) = FALSE(). // s_sub does not inherit from the generic def of s_super, not subtypes
    isAssignableTo_dataTypes(_, _, TRUE(), [], _, _) = TRUE().  // s_super does not have type arguments and s_sub inherits from s_super_def
    isAssignableTo_dataTypes(s_sub, s_super, TRUE(), [_|_], s_super_def, assignableKind) =
      isTypeArgsCompatible(instantiated_s_sub_super_instance, s_super, assignableKind)
    :-
      {s_sub_super_instance}
      query ()
        filter INHERIT? (P INHERIT)*
           and { s :- getGenericDef(s) == s_super_def }
            in s_sub |-> [(_, s_sub_super_instance)],
      instantiateGenericParams(s_sub, s_sub_super_instance) == instantiated_s_sub_super_instance.

      // instantiate generic parameters in instance s2 with the type arguments of s1
      instantiateGenericParams : scope * scope -> scope
      instantiateGenericParams(s1, s2) = s_data_instance_instantiated :-
        {instantiated}
        new s_data_instance_instantiated,
        !root[getRoot(s2)] in s_data_instance_instantiated,
        s_data_instance_instantiated -P-> findGenericDef(s2),
        instantiateNamedTypeArgs(s1, s2, getTypeArgs(s2)) == instantiated,
        declareTypeArgsFromTuples(s_data_instance_instantiated, instantiated).

        instantiateNamedTypeArg : scope * scope * (GenericParameter * TYPE) -> (GenericParameter * TYPE)
        instantiateNamedTypeArgs maps instantiateNamedTypeArg(*, *, list(*)) = list(*)
        instantiateNamedTypeArg(s1, s2, (name, T)) = (name, instantiateTypeArgs_1(s1, T, [])).

        declareTypeArgsFromTuples : scope * list((GenericParameter * TYPE))
        declareTypeArgsFromTuples(_, []).
        declareTypeArgsFromTuples(s, [(name, T)|args]) :-
          declareTypeArg(s, name, T),
          declareTypeArgsFromTuples(s, args).

    // check if s1 is compatible with s2. Assumes s1 is an instance of data
    // type dt and that s2 is either also an instance or the generic definition
    // "Compatible" means that the types are equal, or the second one is a
    // wildcard and the first one falls within the bounds
    isTypeArgsCompatible : scope * scope * AssignableKind -> BOOLEAN
    isTypeArgsCompatible(s1, s2, assignableKind) =
      isTypeArgsCompatible_1(s1, s2, getGenericDef(s1), assignableKind).

      // s1 is an instance
      // s2 is either an instance or a data definition.
      // third argument (s2/s_data_def) is data definition
      isTypeArgsCompatible_1 : scope * scope * scope * AssignableKind -> BOOLEAN
      isTypeArgsCompatible_1(s1, s2, s2, _) = TRUE().
        // s2 is a generic data definition, s1 is an instance of it.
        // s1 is a subtype by definition.

      isTypeArgsCompatible_1(s1, s2, s_data_def, assignableKind) =
        // s2 is an instance of s_data_def
        allTrue(isTypeArgsCompatible_2(tmp1@getTypeArgs(s1), s2, assignableKind)) :-
        {tmp2}
        tmp2 == ppScope(s1),
        try{false}|note$[DEBUG - type arguments in [tmp2]: [tmp1]].

      // Checks if a type argument in s1 is compatible with s2.
      isTypeArgCompatible : (GenericParameter * TYPE) * scope * AssignableKind -> BOOLEAN
      isTypeArgsCompatible_2 maps isTypeArgCompatible(list(*), *, *) = list(*)
      isTypeArgCompatible((name, ty1), s2, assignableKind) =
        out@isTypeArgCompatible_1(ty1, ty2@resolveUniqueTypeArg(s2, name, "no error node"), assignableKind) :-
          try{false}|note$[DEBUG - type arg [ty1] for parameter [name] is compatible with [ty2] == [out]].

        // todo: can be replaced with assignableTo(T1, T2, FALSE())?
        isTypeArgCompatible_1 : TYPE * TYPE * AssignableKind -> BOOLEAN
        isTypeArgCompatible_1(ty, ty, _) = TRUE().
        isTypeArgCompatible_1(DataType(s1), DataType(s2), assignableKind) = andB(
            isScopeEqual(getGenericDef(s1), getGenericDef(s2)),
            isTypeArgsCompatible(s1, s2, assignableKind)
          ).
        isTypeArgCompatible_1(T, WildcardType(ub, lb), assignableKind) = andB(
            isAssignableTo(T, typeOrTopType(ub), requireExactTypeParamEquality),
            isTypeEntirelyAboveLowerBound(T, typeOrBottomType(lb), assignableKind)
          ).
        isTypeArgCompatible_1(T1, T2@GenericParameter2TYPE(_), assignableKind) = out@andB(
            tmp1@isAssignableTo(T1, ub, assignableKind),
            tmp2@isTypeEntirelyAboveLowerBound(T2, lb, assignableKind)
          ) :-
            {tmp3} ppTYPE(T1) == tmp3,
            {tmp4} ppTYPE(T2) == tmp4,
            try{false}|note$[DEBUG - type argument [tmp3] compatible to [tmp4] == [out]. Bounds: ([ub], [lb]). Assignable to upper bound: [tmp1], above lower bound [tmp2]],
            getBounds(T2) == (ub, lb).
        isTypeArgCompatible_1(T1, T2, _) = FALSE().

          isScopeEqual : scope * scope -> BOOLEAN
          isScopeEqual(s, s) = TRUE().
          isScopeEqual(s1, s2) = FALSE().

          // Checks that Type T does not include TYPEs below lower bound lb
          isTypeEntirelyAboveLowerBound : TYPE * TYPE * AssignableKind -> BOOLEAN
          isTypeEntirelyAboveLowerBound(WildcardType(_, lb1), lb2, assignableKind) =
            isAssignableTo(lb2, typeOrBottomType(lb1), assignableKind).
          isTypeEntirelyAboveLowerBound(T, lb, assignableKind) =
            isAssignableTo(lb, T, assignableKind).

  isAssignableTo(_, TopType(), _) = TRUE().
  isAssignableTo(BottomType(), _, _) = TRUE().

  isAssignableTo(WildcardType(upper_bound, lower_bound), T, assignableKind) =
    isAssignableTo(typeOrTopType(upper_bound), T, assignableKind).
  isAssignableTo(T@WildcardType(_, _), T@WildcardType(_, _), _) = TRUE().
  isAssignableTo(T, WildcardType(upper_bound, lower_bound), TypeArgKind()) =
    withinBounds(getBounds(T), (typeOrTopType(upper_bound), typeOrBottomType(lower_bound))).
  isAssignableTo(T, WildcardType(upper_bound, _), ArgumentKind()) =
    isAssignableTo(T, typeOrTopType(upper_bound), ArgumentKind()).
  isAssignableTo(T, WildcardType(upper_bound, _), ExpressionKind()) =
    isAssignableTo(T, typeOrTopType(upper_bound), ExpressionKind()).

  isAssignableTo(T1@GenericParameter2TYPE(tmp3), T2, assignableKind) =
    out@isAssignableTo(upper_bound, T2, assignableKind) :-
      {s name} tmp3 == GenericParameter(s, name),
      {tmp1} tmp1 == ppTYPE(upper_bound),
      {tmp2} tmp2 == ppTYPE(T2),
      try{false}|note$[DEBUG - generic parameter [name] in [s] with upper bound [tmp1] ([upper_bound]) is assignable to [tmp2] ([T2]) == [out]],
      getBounds(T1) == (upper_bound, _).
  isAssignableTo(T@GenericParameter2TYPE(_), T@GenericParameter2TYPE(_), _) = TRUE() :-
    {name}
    T == GenericParameter2TYPE(GenericParameter(_, name)),
    try{false}|note$[DEBUG - generic parameter [name] is assignable to itself].
  isAssignableTo(T1, T2@GenericParameter2TYPE(_), TypeArgKind()) =
    out@withinBounds(tmp1@getBounds(T1), tmp2@getBounds(T2)) :-
      {s name} T2 == GenericParameter2TYPE(GenericParameter(s, name)),
      {ub1 lb1} (ub1, lb1) == tmp1,
      {ub2 lb2} (ub2, lb2) == tmp2,
      {tmp3} tmp3 == ppTYPE(ub1),
      {tmp4} tmp4 == ppTYPE(lb1),
      {tmp5} tmp5 == ppTYPE(ub2),
      {tmp6} tmp6 == ppTYPE(lb2),
      {tmp7} tmp7 == ppTYPE(T1),
      try{false}|note$[DEBUG - [tmp7] ([T1]) is assignable to generic parameter [name] in [s] with upper bound [tmp5] ([ub1]) == [out]].
  isAssignableTo(T1, T2@GenericParameter2TYPE(_), ArgumentKind()) =
    isAssignableTo(T1, lower_bound, ArgumentKind()) :-
      getBounds(T2) == (_, lower_bound).
  isAssignableTo(T1, T2@GenericParameter2TYPE(_), ExpressionKind()) =
    isAssignableTo(T1, lower_bound, ExpressionKind()) :-
      getBounds(T2) == (_, lower_bound).

// foo<T>(elem: T)

// func bar1<F : Fruit>() -> {
//   foo<F>(apple) // disallowed: F could be banana
//                 // No argument type except bottom type would make this call legal
// }
// func bar2<F -: Fruit>() -> {
//   foo<F>(apple) // allowed
// }

/*

In one case, the type parameter is bound to a particular value, and assigning is only allowed if the argument is that particular value.
In the other case, the type parameter is unbound, and the argument just has to fall within the bounds.
Cases:
- In all cases, a wildcard is just a type parameter that is not used anywhere else. (correct?)
- override check: check if bounds for type parameters are compatible.
  - Could have free type parameters from functions, sub datatype.
  - All bounds should be exactly equal.
  - type parameters considered equal if occurence equal after renaming.
- override check: check if parameters are compatible.
  - Could have free type parameters from functions, sub datatype.
  - All parameters should be exactly equal.
  - type parameters considered equal if occurence equal after renaming.
- override check: check if return types are compatible.
  - Could have free type parameters from functions, sub datatype.
  - sub return type must be subtype of super return type.
  - type parameters considered equal if occurence equal after renaming.
- assign type argument (from call or type reference) to type parameter.
  - Could have free type parameters from function type params or from datatype for super type declaration.
  - argument should be compatible: argument upper and lower bound within parameter upper and lower bound.
  - type parameters considered compatible if argument upper and lower bound within parameter upper and lower bound.
- assign argument (from call) to parameter.
  - Can have free type parameters from function that makes the call: func foo<T>() -> bar<T>()
  - expression type should be compatible: expression type upper bound within declared type _lower_ bound or equal generic param occurence.
  - type parameters considered compatible if expression type upper and lower bound within declared type upper and lower bound.
- assign expression to value (valDec).
  - Could have free type parameters from function type params.
  - expression type should be compatible: expression type upper bound within declared type upper bound. (lower bound does not matter because of subtyping)
  - type parameters considered compatible if expression type upper and lower bound within declared type upper and lower bound.

*/

  isAssignableTo(T, T, _) = TRUE().
  isAssignableTo(_, _, _) = FALSE().

  /**
   * isAllAssignableTo(T1s, T2s, assignableKind) -> bool
   * Returns TRUE if the types in [T1s] are pairwise assignable to [T2s], FALSE
   * otherwise. Also returns FALSE if the lists don't have the same length.
   * This is useful for comparing parameter lists of functions.
   * Delegates to isAssignableTo.
   */
  isAllAssignableTo : list(TYPE) * list(TYPE) * AssignableKind -> BOOLEAN
  isAllAssignableTo([], [], _) = TRUE().
  isAllAssignableTo(Ts@[_|_], [], _) = FALSE().
  isAllAssignableTo([], Ts@[_|_], _) = FALSE().
  isAllAssignableTo([T1|T1s], [T2|T2s], assignableKind) =
    andB(isAssignableTo(T1, T2, assignableKind), isAllAssignableTo(T1s, T2s, assignableKind)).

  /**
   * isInvariant(T1, T2) = is_invariant
   * Checks if T1 and T2 are invariant, which means that T1 and T2 are equal
   * (T1 is a subtype of T2, T2 is a subtype of T1)
   */
  isInvariant : TYPE * TYPE -> BOOLEAN
  isInvariant(T, T) = TRUE().
  isInvariant(NullableType(T1), NullableType(T2)) = isInvariant(T1, T2).
  isInvariant(ListType(T1), ListType(T2)) = isInvariant(T1, T2).
  isInvariant(TupleType(T1s), TupleType(T2s)) = isAllInvariant(T1s, T2s).
  isInvariant(SupplierType(T1), SupplierType(T2)) = isInvariant(T1, T2).
  isInvariant(DataType(s1), DataType(s2)) = andB(
    isScopeEqual(findGenericDef(s1), findGenericDef(s2)),
    isAllInvariant(getTypeArgTypes(getTypeArgs(s1)), getTypeArgTypes(getTypeArgs(s2)))
  ).
  isInvariant(T1, T2) = FALSE().

  /**
   * isAllInvariant(T1s, T2s) = res
   * Checks that all types in lists [T1s] and [T2s] are pairwise invariant.
   * Returns FALSE() if [T1s] and [T2s] have different lengths.
   */
  isAllInvariant : list(TYPE) * list(TYPE) -> BOOLEAN
  isAllInvariant([], []) = TRUE().
  isAllInvariant([_|_], []) = FALSE().
  isAllInvariant([], [_|_]) = FALSE().
  isAllInvariant([T1|T1s], [T2|T2s]) =
    andB(isInvariant(T1, T2), isAllInvariant(T1s, T2s)).

  /**
   * Returns the first element in the list that is TRUE(), or the default otherwise.
   */
  firstTrueT : list((BOOLEAN * TYPE)) * TYPE -> TYPE
  firstTrueT([], T) = T.
  firstTrueT([(FALSE(), _)|rest], T) = firstTrueT(rest, T).
  firstTrueT([(TRUE(), T)|_], _) = T.

  /**
   * makeNullable(ty)
   * Make Type [ty] nullable if it is not already.
   * This returns either NullType() or NullableType(_)
   */
  makeNullable : TYPE -> TYPE
  makeNullable(NullType()) = NullType().
  makeNullable(T@NullableType(_)) = T.
  makeNullable(TopType()) = TopType().
  makeNullable(T) = NullableType(T).

  /**
   * lub(T1, T2)
   * Returns the least upper bound of types [T1] and [T2].
   */
  lub : TYPE * TYPE -> TYPE
  lubs maps lub(list(*), list(*)) = list(*)
  lub(NullType(), T) = makeNullable(T).
  lub(T, NullType()) = makeNullable(T).
  lub(NullableType(T1), NullableType(T2)) = NullableType(lub(T1, T2)).
  lub(EmptyListType(), ListType(T)) = ListType(T).
  lub(ListType(T), EmptyListType()) = ListType(T).
  lub(T1@DataType(_), T2@DataType(_)) =
    lub_dataTypeGuard(isAssignableTo(T1, T2, TypeArgKind()), isAssignableTo(T2, T1, TypeArgKind()), T1, T2).

    lub_dataTypeGuard : BOOLEAN * BOOLEAN * TYPE * TYPE -> TYPE
    lub_dataTypeGuard(TRUE(), _, _, T2) = T2.
    lub_dataTypeGuard(_, TRUE(), T1, _) = T1.
    lub_dataTypeGuard(FALSE(), FALSE(), T1@DataType(s1), T2@DataType(s2)) =
      lub_datatype(maybe_s_common, s1, s2)
    :-
      // find all scopes from s1 that s2 inherits from, take the shortest one.
      // This is guaranteed to be a generic definition unless one of the two is a subtype of the other,
      // or they do not have an explicit common super type.
      // them being subtypes is already covered by lub_dataTypeGuard
      query ()
        filter (P|INHERIT)*
           and { s_common_candidate :- inherits(s2, s_common_candidate) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> maybe_s_common.

    // list contains either no scopes or single scope s_data_common, which is a definition
    lub_datatype : list((path * scope)) * scope * scope -> TYPE
    lub_datatype([], _, _) = TopType().
    lub_datatype([(_, s_common)], s1, s2) = DataType(s_common_instance) :-
      {s3 s4 type_arg_params type_arg_tys merged_type_args}
      new s_common_instance,
      !root[getRoot(s_common)] in s_common_instance,
      s_common_instance -P-> s_common,
      query ()
        filter (P|INHERIT)*
           and { s3_candidate :- isInstanceOf(s3_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> [(_, s3)],
      query ()
        filter (P|INHERIT)*
           and { s4_candidate :- isInstanceOf(s4_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s2 |-> [(_, s4)],
      unzipTypeArgs(getTypeArgs(s3)) == (type_arg_params, type_arg_tys),
      lubs_type_args(type_arg_tys, resolveUniqueTypeArgs(s4, type_arg_params, "no error node")) == merged_type_args,
      declareTypeArgs(s_common_instance, type_arg_params, merged_type_args).

        isInstanceOf: scope * scope -> BOOLEAN
        isInstanceOf(s1, s2) = isInstanceOf_listContains(occs, s2) :-
          query () filter P in s1 |-> occs.

          isInstanceOf_listContains : list((path * scope)) * scope -> BOOLEAN
          isInstanceOf_listContains([], _) = FALSE().
          isInstanceOf_listContains([(_, s)|_], s) = TRUE().
          isInstanceOf_listContains([(_, s')|rest], s) = isInstanceOf_listContains(rest, s).

        unzipTypeArgs : list((GenericParameter * TYPE)) -> (list(GenericParameter) * list(TYPE))
        unzipTypeArgs([]) = ([], []).
        unzipTypeArgs([(param, type)|type_args]) = ([param|params], [type|types]) :-
          unzipTypeArgs(type_args) == (params, types).

        lub_type_arg : TYPE * TYPE -> TYPE
        lubs_type_args maps lub_type_arg(list(*), list(*)) = list(*)
        lub_type_arg(T1, T2) = lub_type_arg_1(T1, T2, compatible1, compatible2) :-
          isTypeArgCompatible_1(T2, T1, TypeArgKind()) == compatible1,
          isTypeArgCompatible_1(T1, T2, TypeArgKind()) == compatible2.

          lub_type_arg_1 : TYPE * TYPE * BOOLEAN * BOOLEAN -> TYPE
          lub_type_arg_1(T, T, _, _) = T.
          lub_type_arg_1(T1, _, TRUE(), _) = T1.
          lub_type_arg_1(_, T2, _, TRUE()) = T2.
          lub_type_arg_1(T1, T2, FALSE(), FALSE()) =
            WildcardType(UpperBoundType(lub(getUpperBound(T1), getUpperBound(T2))), NoLowerBoundType()).

          getUpperBound : TYPE -> TYPE
          getUpperBound(GenericParameter2TYPE(GenericParameter(s, name))) = upper_bound :-
            resolveGenericParam(s, name) == [(_, (_, (upper_bound, _)))].
          getUpperBound(WildcardType(upper_bound, _)) = typeOrTopType(upper_bound).
          getUpperBound(T) = T.

  lub(TopType(), T) = TopType().
  lub(T, TopType()) = TopType().
  lub(BottomType(), T) = T.
  lub(T, BottomType()) = T.
  lub(WildcardType(upper_bound, _), T) = lub(typeOrTopType(upper_bound), T).
  lub(T, WildcardType(upper_bound, _)) = lub(T, typeOrTopType(upper_bound)).
  lub(T, T) = T.
  lub(T1, T2) = firstTrueT([
    (isAssignableTo(T1, T2, ExpressionKind()), T2),
    (isAssignableTo(T2, T1, ExpressionKind()), T1)],
    TopType()).


  /**
   * listLub(list)
   * Returns the least upper bound of a list of types.
   */
  listLub : list(TYPE) -> TYPE
  listLub([]) = BottomType() :- try { false } | warning "BUG?: called listLub with empty list".
  listLub([T]) = T.
  listLub([T1|[T2|[]]]) = lub(T1, T2).
  listLub([T1|[T2|rest]]) = listLub([lub(T1, T2) | rest]).

  /**
   * Holds if the two types are comparable.
   * This disregards the possibilty for two incomparable but Nullable values to
   * both be null and the possibilty for two list types to both be empty lists.
   */
  comparable : TYPE * TYPE
  listComparable maps comparable(list(*), list(*))
  comparable(TupleType(T1s), TupleType(T2s)) :- listComparable(T1s, T2s).
  comparable(ListType(T1), ListType(T2)) :- comparable(T1, T2).
  comparable(SupplierType(T1), SupplierType(T2)) :- comparable(T1, T2).
  comparable(T1, T2) :-
    orB(isAssignableTo(T1, T2, ExpressionKind()), isAssignableTo(T2, T1, ExpressionKind())) == TRUE().

rules

  /**
   * typeOf(s, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you have a scope with type arguments, use typeOfWithTypeArgScope
   */
  typeOf : scope * Type -> TYPE
  typesOf maps typeOf(*, list(*)) = list(*)
  typeOf(s, ty) = typeOfWithTypeArgScope(s, emptyScope(s), ty, FALSE()).

  /**
   * typeOfWithTypeArgScope(s, s_type_args, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you don't have a scope with type arguments, use typeOf
   * [resolve_in_super_types] specifies if type arguments can be looked up in
   * super types or not. If they can, resolution will follow P and INHERIT
   * edges. Otherwise, it will only follow P edges.
   */
  typeOfWithTypeArgScope : scope * scope * Type * BOOLEAN -> TYPE
  typesOfWithTypeArgScope_1 maps typeOfWithTypeArgScope(*, *, list(*), *) = list(*)
  typeOfWithTypeArgScope(s, s_type_args, ty, resolve_in_super_types) =
    type@typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types) :-
    @ty.type := type.

  typeOfWithTypeArgScope_1 : scope * scope * Type * BOOLEAN -> TYPE
  typeOfWithTypeArgScope_1(_, _, UnitTy(), _) = UnitType().
  typeOfWithTypeArgScope_1(_, _, BoolTy(), _) = BoolType().
  typeOfWithTypeArgScope_1(_, _, IntTy(), _)  = IntType().
  typeOfWithTypeArgScope_1(_, _, StrTy(), _)  = StrType().
  typeOfWithTypeArgScope_1(_, _, PathTy(), _) = PathType().
  typeOfWithTypeArgScope_1(s, s_type_args, DataTy2Type(data_ty), resolve_in_super_types) = typeOfDataTy(s, s_type_args, data_ty, resolve_in_super_types).
  typeOfWithTypeArgScope_1(s, s_type_args, TupleTy(tys), resolve_in_super_types) = TupleType(typesOfWithTypeArgScope_1(s, s_type_args, tys, resolve_in_super_types)).
  typeOfWithTypeArgScope_1(s, s_type_args, ListTy(ty), resolve_in_super_types) = ListType(typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types)).
  typeOfWithTypeArgScope_1(s, s_type_args, SupplierTy(ty), resolve_in_super_types) = SupplierType(typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types)).
  typeOfWithTypeArgScope_1(s, s_type_args, NullableTy(ty, marker), resolve_in_super_types) = NullableType(typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types)) :-
    try { ty != NullableTy(_, _) } | warning $[No-op: double nullable has no effect] @marker.
  typeOfWithTypeArgScope_1(s, s_type_args, Wildcard(upper_bound, lower_bound), resolve_in_super_types) = WildcardType(upper_bound_ty, lower_bound_ty) :-
    {upper_error_node lower_error_node}
    typeOfUpperBound(s, s_type_args, upper_bound, resolve_in_super_types) == upper_bound_ty,
    typeOfLowerBound(s, s_type_args, lower_bound, resolve_in_super_types) == lower_bound_ty,
    bothBoundsOk(upper_bound, lower_bound).

  /**
   * typeOfDataTy(s, s_type_args, data_ty, resolve_in_super_types) = data_type
   * Get the Semantic type [data_type] of a syntactic type [data_ty].
   * Uses [s] to resolve types and [s_type_args] to resolve type arguments.
   * [resolve_in_super_types] specifies if type arguments can be looked up in
   * super types or not. If they can, resolution will follow P and INHERIT
   * edges. Otherwise, it will only follow P edges.
   */
  typeOfDataTy : scope * scope * DataTy * BOOLEAN -> TYPE
  typeOfDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args), resolve_in_super_types) = type :-
    {resolved_params resolvedData}
    resolveGenericParam(s_type_args, name) == resolved_params,
    resolveData(mergeScopes(s, resolveModuleListToFile(s, modules)), name) == resolvedData,
    isGenericParamOrDataTy(s, s_type_args, data_ty, modules, resolved_params, resolvedData, resolve_in_super_types) == type.

    isGenericParamOrDataTy : scope * scope * DataTy * ModuleList *
      list((path * (GenericParameter * (TYPE * TYPE)))) * list((path * (TYPEID * scope))) * BOOLEAN -> TYPE
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, _, _) = DataType(emptyScope(s)) :-
      false | error $[Undefined datatype [name]] @name.

    // generic parameter
    isGenericParamOrDataTy(s, s_type_args, DataTy(NoModuleList(), name, type_args), NoModuleList(),
      [(_, (param@GenericParameter(_, name'), (upper_bound, _)))], _, resolve_in_super_types) = type :-
      genericParamToType(resolveTypeArgFromNameOnly(s_type_args, name, resolve_in_super_types), param, upper_bound) == type,
      @name.ref := name',
      @name.type := type,
      getTypeArgsList(type_args) == [] | error "Generic parameters do not take type arguments" @type_args.

      genericParamToType : list((path * (GenericParameter * TYPE))) * GenericParameter * TYPE -> TYPE
      genericParamToType([], param, _) = GenericParameter2TYPE(param).
      genericParamToType([(_, (_, ty))], _, _) = ty.
      genericParamToType([(_, (GenericParameter(_, name), _)),_|_], GenericParameter(s, _), _) = DataType(emptyScope(s)) :-
        false | error $[BUG: resolved multiple type arguments named [name]].

    isGenericParamOrDataTy(s, _, DataTy(_, name, type_args), NoModuleList(), [_,_|_], _, _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate declarations for generic parameter [name]] @name.

    // data type
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, [_,_|_], _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate datatype [name]] @name.
    isGenericParamOrDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args), _, _,
      [(_, (name', s_data_def))], resolve_in_super_types) = type@DataType(s_data_instance) :-
      {params}
      new s_data_instance,
      !root[getRoot(s)] in s_data_instance,
      s_data_instance -P-> s_data_def,
      getGenericParams(s_data_def) == params,
      genericArgsOk(s, s_type_args, s_data_instance, params, type_args, resolve_in_super_types, name),
      @name.ref := name',
      @name.type := type.

      // s: current function/module scope
      // s_type_args: scope for looking up defined data types
      // s_data_instance: scope for the instance that we are typing right now
      // s_data_def: definition for s_data_instance

  genericArgsOk : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) * TypeArgs * BOOLEAN * string
  genericArgsOk(_, _, _, [], NoTypeArgs(), _, _). // separate case to force unification of params before evaluating this.
  genericArgsOk(_, _, _, params@[_|_], NoTypeArgs(), _, error_node) :-
    {names}
    getGenericParamNames(params) == names,
    false | error $[Cannot derive type arguments. Provide type arguments explicitly for parameters [names]] @error_node.

    getGenericParamName : (GenericParameter * TYPE * TYPE) -> string
    getGenericParamNames maps getGenericParamName(list(*)) = list(*)
    getGenericParamName((GenericParameter(_, name), _, _)) = name.

  genericArgsOk(s, s_type_args, s_data_instance, params, type_args@TypeArgs(arg_types), resolve_in_super_types, _) :-
    genericArgsOk_1(s, s_type_args, s_data_instance, params, type_args, resolve_in_super_types, sameLength(params, arg_types)).

    sameLength : list((GenericParameter * TYPE * TYPE)) * list(Type) -> (list(TYPEID) * list(Type))
    sameLength([], []) = ([], []).
    sameLength([(GenericParameter(_, name), _, _)|params], []) = ([name|names], []) :-
      sameLength(params, []) == (names, []).
    sameLength([], remaining@[_|_]) = ([], remaining).
    sameLength([_|params], [_|type_args]) = sameLength(params, type_args).

  genericArgsOk_1 : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) *
    TypeArgs * BOOLEAN * (list(TYPEID) * list(Type))
  genericArgsOk_1(_, _, _, _, type_args, _, (remaining@[_|_], [])) :-
    false | error $[Not enough type arguments, unmatched generic arguments: [remaining]] @type_args.
  genericArgsOk_1(_, _, _, _, type_args, _, ([], remaining@[_|_])) :-
    false | error $[Too many type arguments, unmatched type arguments: [remaining]] @type_args.
  genericArgsOk_1(s, s_type_args, s_data_instance, params, TypeArgs(type_args), resolve_in_super_types, ([], [])) :-
    genericArgsOk_2(s, s_type_args, s_data_instance, params, type_args, resolve_in_super_types).

  genericArgOk : scope * scope * scope * (GenericParameter * TYPE * TYPE) * Type * BOOLEAN
  genericArgsOk_2 maps genericArgOk(*, *, *, list(*), list(*), *)
  genericArgOk(s, s_type_args, s_data_instance, (param@GenericParameter(_, name), upper_bound, lower_bound), arg, resolve_in_super_types) :-
    {arg_ty}
    {tmp1} tmp1 == isAssignableTo(arg_ty, upper_bound, TypeArgKind()),
    {tmp2} tmp2 == isAssignableTo(lower_bound, arg_ty, TypeArgKind()),
    {tmp3 tmp4}
    tmp3 == ppTYPE(upper_bound),
    tmp4 == ppTYPE(lower_bound),
    try{false}|note$[DEBUG - checking [arg] for param [name] --> [arg_ty]. Assignable to upper bound [tmp3] ([upper_bound]) == [tmp1], to lower bound [tmp4] ([lower_bound]) == [tmp2] --- s_type_args: [s_type_args]],
    typeOfWithTypeArgScope(s, s_type_args, arg, resolve_in_super_types) == arg_ty,
    declareTypeArg(s_data_instance, param, arg_ty),
    try { tmp1 == TRUE() } | error $[Type mismatch: [arg_ty] is not within upper bound [upper_bound] for type parameter [name]],
    try { tmp2 == TRUE() } | error $[Type mismatch: [arg_ty] is not within lower bound [lower_bound] for type parameter [name]].

  /**
   * instantiateTypeArgs(s, T) = instantiated_type
   * instantiate [T] to a type [instantiated_type].
   * This recursively and exhaustively replaces GenericParameter2TYPE(_) with
   * its type argument. If no type argument exists it will leave the generic
   * parameter as is. This is used when checking if a method overrides another.
   */
  instantiateTypeArgs : scope * TYPE -> TYPE
  instantiateTypeArgsInAll maps instantiateTypeArgs(*, list(*)) = list(*)
  instantiateTypeArgs(s, T) = instantiateTypeArgs_1(s, T, []).

    instantiateTypeArgs_1 : scope * TYPE * list(GenericParameter) -> TYPE
    instantiateTypeArgsInAll_1 maps instantiateTypeArgs_1(*, list(*), *) = list(*)
    instantiateTypeArgs_1(_, T, _) = T.
    instantiateTypeArgs_1(s, DataType(s_data), params) =
      DataType(instantiateGenericParams(s, s_data)).
    instantiateTypeArgs_1(s, TupleType(tys), params) = TupleType(instantiateTypeArgsInAll_1(s, tys, params)).
    instantiateTypeArgs_1(s, ListType(ty), params) = ListType(instantiateTypeArgs_1(s, ty, params)).
    instantiateTypeArgs_1(s, SupplierType(ty), params) = SupplierType(instantiateTypeArgs_1(s, ty, params)).
    instantiateTypeArgs_1(s, NullableType(ty), params) = NullableType(instantiateTypeArgs_1(s, ty, params)).
    instantiateTypeArgs_1(s, WildcardType(upper_bound, lower_bound), params) =
      WildcardType(
        instantiateTypeArgs_wildcardUpperbound(s, upper_bound, params),
        instantiateTypeArgs_wildcardLowerbound(s, lower_bound, params)
      ).

      instantiateTypeArgs_wildcardUpperbound : scope * UpperBoundType * list(GenericParameter) -> UpperBoundType
      instantiateTypeArgs_wildcardUpperbound(_, T@NoUpperBoundType(), _) = T.
      instantiateTypeArgs_wildcardUpperbound(s, UpperBoundType(ub), params) = UpperBoundType(instantiateTypeArgs_1(s, ub, params)).

      instantiateTypeArgs_wildcardLowerbound : scope * LowerBoundType * list(GenericParameter) -> LowerBoundType
      instantiateTypeArgs_wildcardLowerbound(_, T@NoLowerBoundType(), _) = T.
      instantiateTypeArgs_wildcardLowerbound(s, LowerBoundType(lb), params) = LowerBoundType(instantiateTypeArgs_1(s, lb, params)).

    instantiateTypeArgs_1(s, GenericParameter2TYPE(param@GenericParameter(s_param, _)), params) =
      instantiateTypeArgs_genericParameter(s, resolved_arg, param, [param|params], seen)
    :-
      resolveTypeArg(s, param) == resolved_arg,
      containsGenericParam(params, param) == seen.

      containsGenericParam : list(GenericParameter) * GenericParameter -> BOOLEAN
      containsGenericParam([], _) = FALSE().
      containsGenericParam([param|_], param) = TRUE().
      containsGenericParam([param'|params], param) = containsGenericParam(params, param).

      instantiateTypeArgs_genericParameter : scope * list((path * (GenericParameter * TYPE))) *
        GenericParameter * list(GenericParameter) * BOOLEAN -> TYPE
      instantiateTypeArgs_genericParameter(_, [], param, _, _) = GenericParameter2TYPE(param).
      instantiateTypeArgs_genericParameter(s, [_], param, params, TRUE()) = GenericParameter2TYPE(param).
      instantiateTypeArgs_genericParameter(s, [(_, (_, T))], _, params, FALSE()) = instantiateTypeArgs_1(s, T, params).
      instantiateTypeArgs_genericParameter(s, [_,_|_], GenericParameter(_, name), _, _) = DataType(emptyScope(s)) :-
        false | error $[BUG: resolved multiple type arguments named [name]].
