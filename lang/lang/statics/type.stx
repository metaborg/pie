module statics/type

imports

  signatures/constructors-sig
  signatures/data-sig
  signatures/type-sig
  statics/base
  statics/common
  statics/type_common
  statics/module

rules // operations on types

  /**
   * inherits(s_sub, s_super) -> res
   * Returns TRUE() if s_sub inherits from (can be reached by only following
   * INHERIT|P edges from) s_super or is equal to s_super, FALSE() otherwise.
   */
  inherits : scope * scope -> BOOLEAN
  inherits(s_sub, s_super) = inherits_1(paths) :-
    query () filter P? (INHERIT P)* INHERIT? and { s_data :- s_data == s_super } in s_sub |-> paths.

    inherits_1 : list((path * scope)) -> BOOLEAN
    inherits_1([]) = FALSE().
    inherits_1([_|_]) = TRUE().

  /**
   * assignableTo(T1, T2)
   * Checks if an expression of type [T1] can be assigned to a variable of type [T2].
   * Holds if type T1 is a non-strict subtype of type T2.
   * Fails with error if T1 is not a subtype of T2.
   */
  assignableTo : TYPE * TYPE
  listAssignableTo maps assignableTo(list(*), list(*))
  assignableTo(T1, T2) :- isAssignableTo(T1, T2) == TRUE().

  /**
   * isAssignableTo(T1, T2) = res
   * Checks if an expression of type [T1] can be assigned to a variable of type [T2].
   * Returns TRUE() if:
   * - type T1 is a non-strict subtype of type T2
   * - T1 is a wildcard and its upper bound can be assigned to T2
   * - T2 is a wildcard and T1 can be assigned to the lower bound of T2
   * returns FALSE() otherwise.
   * May fail on unbound variables.
   */
  isAssignableTo : TYPE * TYPE -> BOOLEAN
  isAssignableTo(NullType(), NullableType(_)) = TRUE().
  isAssignableTo(T1, NullableType(T2)) = isAssignableTo(T1, T2).
  isAssignableTo(NullableType(T1), NullableType(T2)) = isAssignableTo(T1, T2).
  isAssignableTo(EmptyListType(), ListType(_)) = TRUE().
  isAssignableTo(DataType(s_sub), DataType(s_super)) =
    isAssignableTo_dataTypes(s_sub, s_super, inherits, type_args, s_super_def)
  :-
    findGenericDef(s_super) == s_super_def,
    inherits(s_sub, s_super_def) == inherits,
    getTypeArgs(s_super) == type_args.

    /*
     * Explanation of implementation
     * 1. Make sure that they could be subtypes: if !inherits(s_sub, findGenericDef(s_super)) then FALSE()
     * 2. If s_super is a definition, s_sub is a subtype by definition: if getTypeArgs(s_super) == [] then TRUE()
     * 3. Else: s_super is an instance. Find s_super_def by following P edge: getGenericDef(s_super) == s_super_def
     *    [note] s_sub is either an instance of s_super_def, or an instance or generic def of a strict subtype of s_super_def.
     * 4. Get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def:
     *    query ()
     *      filter INHERIT? (P INHERIT)*
     *         and { s :- getGenericDef(s) == s_super_def }
     *          in s_sub |-> [(_, s_sub_super_instance)]
     * 5. Check if instances are compatible: isTypeArgsCompatible(s_sub_super_instance, s_super)
     */
    isAssignableTo_dataTypes : scope * scope * BOOLEAN * list((GenericParameter * TYPE)) * scope -> BOOLEAN
    isAssignableTo_dataTypes(s_data, s_data, TRUE(), _, _) = TRUE(). // optimization: s_sub == s_super
    isAssignableTo_dataTypes(_, _, FALSE(), _, _) = FALSE(). // s_sub does not inherit from the generic def of s_super, not subtypes
    isAssignableTo_dataTypes(_, _, TRUE(), [], _) = TRUE().  // s_super does not have type arguments and s_sub inherits from s_super_def
    isAssignableTo_dataTypes(s_sub, s_super, TRUE(), [_|_], s_super_def) =
      isTypeArgsCompatible(instantiated_s_sub_super_instance, s_super)
    :-
      {s_sub_super_instance}
      query ()
        filter INHERIT? (P INHERIT)*
           and { s :- getGenericDef(s) == s_super_def }
            in s_sub |-> [(_, s_sub_super_instance)],
      instantiateGenericParams(s_sub, s_sub_super_instance) == instantiated_s_sub_super_instance.

      // instantiate generic parameters in instance s2 with the type arguments of s1
      instantiateGenericParams : scope * scope -> scope
      instantiateGenericParams(s1, s2) = s_data_instance_instantiated :-
        {instantiated}
        new s_data_instance_instantiated,
        !root[getRoot(s2)] in s_data_instance_instantiated,
        s_data_instance_instantiated -P-> getGenericDef(s2),
        instantiateNamedTypeArgs(s1, s2, getTypeArgs(s2)) == instantiated,
        declareTypeArgsFromTuples(s_data_instance_instantiated, instantiated).

        instantiateNamedTypeArg : scope * scope * (GenericParameter * TYPE) -> (GenericParameter * TYPE)
        instantiateNamedTypeArgs maps instantiateNamedTypeArg(*, *, list(*)) = list(*)
        instantiateNamedTypeArg(s1, s2, (name, T)) = (name, instantiateTypeArgs_1(s1, T, [])).

        declareTypeArgsFromTuples : scope * list((GenericParameter * TYPE))
        declareTypeArgsFromTuples(_, []).
        declareTypeArgsFromTuples(s, [(name, T)|args]) :-
          declareTypeArg(s, name, T),
          declareTypeArgsFromTuples(s, args).

    // check if s1 is compatible with s2. Assumes s1 is an instance of data
    // type dt and that s2 is either also an instance or the generic definition
    // "Compatible" means that the types are equal, or the second one is a
    // wildcard and the first one falls within the bounds
    isTypeArgsCompatible : scope * scope -> BOOLEAN
    isTypeArgsCompatible(s1, s2) = isTypeArgsCompatible_1(s1, s2, getGenericDef(s1)).

      // s1 is an instance
      // s2 is either an instance or a data definition.
      // third argument (s2/s_data_def) is data definition
      isTypeArgsCompatible_1 : scope * scope * scope -> BOOLEAN
      isTypeArgsCompatible_1(s1, s2, s2) = TRUE().
        // s2 is a generic data definition, s1 is an instance of it.
        // s1 is a subtype by definition.

      isTypeArgsCompatible_1(s1, s2, s_data_def) =
        // s2 is an instance of s_data_def
        allTrue(isTypeArgsCompatible_2(getTypeArgs(s1), s2)).

      // Checks if a type argument in s1 is compatible with s2.
      isTypeArgCompatible : (GenericParameter * TYPE) * scope -> BOOLEAN
      isTypeArgsCompatible_2 maps isTypeArgCompatible(list(*), *) = list(*)
      isTypeArgCompatible((name, ty1), s2) =
        isTypeArgCompatible_1(ty1, resolveUniqueTypeArg(s2, name, "no error node")).

        isTypeArgCompatible_1 : TYPE * TYPE -> BOOLEAN
        isTypeArgCompatible_1(ty, ty) = TRUE().
        isTypeArgCompatible_1(DataType(s1), DataType(s2)) = andB(
            isScopeEqual(getGenericDef(s1), getGenericDef(s2)),
            isTypeArgsCompatible(s1, s2)
          ).
        isTypeArgCompatible_1(T, WildcardType(ub, lb)) = andB(
            isAssignableTo(T, typeOrTopType(ub)),
            isTypeEntirelyAboveLowerBound(T, typeOrBottomType(lb))
          ).
        isTypeArgCompatible_1(T1, T2) = FALSE().

          isScopeEqual : scope * scope -> BOOLEAN
          isScopeEqual(s, s) = TRUE().
          isScopeEqual(s1, s2) = FALSE().

          // Checks that Type T does not include TYPEs below lower bound lb
          isTypeEntirelyAboveLowerBound : TYPE * TYPE -> BOOLEAN
          isTypeEntirelyAboveLowerBound(WildcardType(_, lb1), lb2) =
            isAssignableTo(lb2, typeOrBottomType(lb1)).
          isTypeEntirelyAboveLowerBound(T, lb) = isAssignableTo(lb, T).

  isAssignableTo(_, TopType()) = TRUE().
  isAssignableTo(BottomType(), _) = TRUE().

  isAssignableTo(WildcardType(upper_bound, lower_bound), T) =
    isAssignableTo(typeOrTopType(upper_bound), T).
  isAssignableTo(T, WildcardType(upper_bound, lower_bound)) =
    isAssignableTo(T, typeOrBottomType(lower_bound)).

  isAssignableTo(GenericParameter2TYPE(GenericParameter(s, name)),
    GenericParameter2TYPE(GenericParameter(s, name))) = TRUE().
  isAssignableTo(GenericParameter2TYPE(GenericParameter(s, name)), T) =
    isAssignableTo(upper_bound, T) :-
      resolveGenericParam(s, name) == [(_, (_, (upper_bound, _)))].
  isAssignableTo(T, GenericParameter2TYPE(GenericParameter(s, name))) =
    isAssignableTo(T, lower_bound) :-
      resolveGenericParam(s, name) == [(_, (_, (_, lower_bound)))].

  isAssignableTo(T, T) = TRUE().
  isAssignableTo(_, _) = FALSE().

  /**
   * isAllAssignableTo(T1s, T2s) -> bool
   * Returns TRUE if the types in [T1s] are pairwise subtypes of [T2s], FALSE
   * otherwise. Also returns FALSE if the lists don't have the same length.
   * This is useful for comparing parameter lists of functions.
   * Delegates to isAssignableTo.
   */
  isAllAssignableTo : list(TYPE) * list(TYPE) -> BOOLEAN
  isAllAssignableTo([], []) = TRUE().
  isAllAssignableTo(Ts@[_|_], []) = FALSE().
  isAllAssignableTo([], Ts@[_|_]) = FALSE().
  isAllAssignableTo([T1|T1s], [T2|T2s]) = andB(isAssignableTo(T1, T2), isAllAssignableTo(T1s, T2s)).

  /**
   * isInvariant(T1, T2) = res
   * Checks if T1 and T2 are invariant, which means that T1 and T2 are equal
   * (T1 is a subtype of T2, T2 is a subtype of T1)
   */
  isInvariant : TYPE * TYPE -> BOOLEAN
  isInvariant(T1, T2) = andB(isInvariant_1(ub1, ub2), isInvariant_1(lb1, lb2)) :-
    getBounds(T1) == (ub1, lb1),
    getBounds(T2) == (ub2, lb2).

    getBounds : TYPE -> (TYPE * TYPE)
    getBounds(WildcardType(ub, lb)) = (typeOrTopType(ub), typeOrBottomType(lb)).
    getBounds(GenericParameter2TYPE(GenericParameter(s, name))) = (ub, lb) :-
      resolveGenericParam(s, name) == [(_, (_, (ub, lb)))] | error $[BUG: not a single declaration of [name] in [s]].
    getBounds(T) = (T, T).

    isInvariant_1 : TYPE * TYPE -> BOOLEAN
    isInvariant_1s maps isInvariant_1(list(*), list(*)) = list(*)
    isInvariant_1(T, T) = TRUE().
    isInvariant_1(NullableType(T1), NullableType(T2)) = isInvariant_1(T1, T2).
    isInvariant_1(ListType(T1), ListType(T2)) = isInvariant_1(T1, T2).
    isInvariant_1(TupleType(T1s), TupleType(T2s)) = allTrue(isInvariant_1s(T1s, T2s)).
    isInvariant_1(SupplierType(T1), SupplierType(T2)) = isInvariant_1(T1, T2).
    isInvariant_1(DataType(s1), DataType(s2)) = andB(
      isScopeEqual(findGenericDef(s1), findGenericDef(s2)),
      isAllInvariant(getTypeArgTypes(getTypeArgs(s1)), getTypeArgTypes(getTypeArgs(s2)))
    ).
    isInvariant_1(T1, T2) = FALSE().

  /**
   * isAllInvariant(T1s, T2s) = res
   * Checks that all types in lists [T1s] and [T2s] are pairwise invariant.
   * Returns FALSE() if [T1s] and [T2s] have different lengths.
   */
  isAllInvariant : list(TYPE) * list(TYPE) -> BOOLEAN
  isAllInvariant([], []) = TRUE().
  isAllInvariant([_|_], []) = FALSE().
  isAllInvariant([], [_|_]) = FALSE().
  isAllInvariant([T1|T1s], [T2|T2s]) =
    andB(isInvariant(T1, T2), isAllInvariant(T1s, T2s)).

  /**
   * Returns the first element in the list that is TRUE(), or the default otherwise.
   */
  firstTrueT : list((BOOLEAN * TYPE)) * TYPE -> TYPE
  firstTrueT([], T) = T.
  firstTrueT([(FALSE(), _)|rest], T) = firstTrueT(rest, T).
  firstTrueT([(TRUE(), T)|_], _) = T.

  /**
   * makeNullable(ty)
   * Make Type [ty] nullable if it is not already.
   * This returns either NullType() or NullableType(_)
   */
  makeNullable : TYPE -> TYPE
  makeNullable(NullType()) = NullType().
  makeNullable(T@NullableType(_)) = T.
  makeNullable(T) = NullableType(T).

  /**
   * lub(T1, T2)
   * Returns the least upper bound of types [T1] and [T2].
   */
  lub : TYPE * TYPE -> TYPE
  lubs maps lub(list(*), list(*)) = list(*)
  lub(NullType(), T) = makeNullable(T).
  lub(T, NullType()) = makeNullable(T).
  lub(NullableType(T1), NullableType(T2)) = NullableType(lub(T1, T2)).
  lub(EmptyListType(), ListType(T)) = ListType(T).
  lub(ListType(T), EmptyListType()) = ListType(T).
  lub(T1@DataType(_), T2@DataType(_)) = lub_dataTypeGuard(isAssignableTo(T1, T2), isAssignableTo(T2, T1), T1, T2).

    lub_dataTypeGuard : BOOLEAN * BOOLEAN * TYPE * TYPE -> TYPE
    lub_dataTypeGuard(TRUE(), _, _, T2) = T2.
    lub_dataTypeGuard(_, TRUE(), T1, _) = T1.
    lub_dataTypeGuard(FALSE(), FALSE(), T1@DataType(s1), T2@DataType(s2)) =
      lub_datatype(maybe_s_common, s1, s2)
    :-
      // find all scopes from s1 that s2 inherits from, take the shortest one.
      // This is guaranteed to be a generic definition unless one of the two is a subtype of the other,
      // or they do not have an explicit common super type.
      // them being subtypes is already covered by lub_dataTypeGuard
      query ()
        filter (P|INHERIT)*
           and { s_common_candidate :- inherits(s2, s_common_candidate) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> maybe_s_common.

    // list contains either no scopes or single scope s_data_common, which is a definition
    lub_datatype : list((path * scope)) * scope * scope -> TYPE
    lub_datatype([], _, _) = TopType().
    lub_datatype([(_, s_common)], s1, s2) = DataType(s_common_instance) :-
      {s3 s4 type_arg_params type_arg_tys merged_type_args}
      new s_common_instance,
      !root[getRoot(s_common)] in s_common_instance,
      s_common_instance -P-> s_common,
      query ()
        filter (P|INHERIT)*
           and { s3_candidate :- isInstanceOf(s3_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> [(_, s3)],
      query ()
        filter (P|INHERIT)*
           and { s4_candidate :- isInstanceOf(s4_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s2 |-> [(_, s4)],
      unzipTypeArgs(getTypeArgs(s3)) == (type_arg_params, type_arg_tys),
      lubs_type_args(type_arg_tys, resolveUniqueTypeArgs(s4, type_arg_params, "no error node")) == merged_type_args,
      declareTypeArgs(s_common_instance, type_arg_params, merged_type_args).

        isInstanceOf: scope * scope -> BOOLEAN
        isInstanceOf(s1, s2) = isInstanceOf_listContains(occs, s2) :-
          query () filter P in s1 |-> occs.

          isInstanceOf_listContains : list((path * scope)) * scope -> BOOLEAN
          isInstanceOf_listContains([], _) = FALSE().
          isInstanceOf_listContains([(_, s)|_], s) = TRUE().
          isInstanceOf_listContains([(_, s')|rest], s) = isInstanceOf_listContains(rest, s).

        unzipTypeArgs : list((GenericParameter * TYPE)) -> (list(GenericParameter) * list(TYPE))
        unzipTypeArgs([]) = ([], []).
        unzipTypeArgs([(param, type)|type_args]) = ([param|params], [type|types]) :-
          unzipTypeArgs(type_args) == (params, types).

        lub_type_arg : TYPE * TYPE -> TYPE
        lubs_type_args maps lub_type_arg(list(*), list(*)) = list(*)
        lub_type_arg(T1, T2) = lub_type_arg_1(T1, T2, compatible1, compatible2) :-
          isTypeArgCompatible_1(T2, T1) == compatible1,
          isTypeArgCompatible_1(T1, T2) == compatible2.

          lub_type_arg_1 : TYPE * TYPE * BOOLEAN * BOOLEAN -> TYPE
          lub_type_arg_1(T, T, _, _) = T.
          lub_type_arg_1(T1, _, TRUE(), _) = T1.
          lub_type_arg_1(_, T2, _, TRUE()) = T2.
          lub_type_arg_1(T1, T2, FALSE(), FALSE()) =
            WildcardType(UpperBoundType(lub(getUpperBound(T1), getUpperBound(T2))), NoLowerBoundType()).

          getUpperBound : TYPE -> TYPE
          getUpperBound(GenericParameter2TYPE(GenericParameter(s, name))) = upper_bound :-
            resolveGenericParam(s, name) == [(_, (_, (upper_bound, _)))].
          getUpperBound(WildcardType(upper_bound, _)) = typeOrTopType(upper_bound).
          getUpperBound(T) = T.

  lub(TopType(), T) = TopType().
  lub(T, TopType()) = TopType().
  lub(BottomType(), T) = T.
  lub(T, BottomType()) = T.
  lub(WildcardType(upper_bound, _), T) = lub(typeOrTopType(upper_bound), T).
  lub(T, WildcardType(upper_bound, _)) = lub(T, typeOrTopType(upper_bound)).
  lub(T, T) = T.
  lub(T1, T2) = firstTrueT([
    (isAssignableTo(T1, T2), T2),
    (isAssignableTo(T2, T1), T1)],
    TopType()).


  /**
   * listLub(list)
   * Returns the least upper bound of a list of types.
   */
  listLub : list(TYPE) -> TYPE
  listLub([]) = BottomType() :- try { false } | warning "BUG?: called listLub with empty list".
  listLub([T]) = T.
  listLub([T1|[T2|[]]]) = lub(T1, T2).
  listLub([T1|[T2|rest]]) = listLub([lub(T1, T2) | rest]).

  /**
   * Holds if the two types are comparable.
   * This disregards the possibilty for two incomparable but Nullable values to
   * both be null and the possibilty for two list types to both be empty lists.
   */
  comparable : TYPE * TYPE
  listComparable maps comparable(list(*), list(*))
  comparable(TupleType(T1s), TupleType(T2s)) :- listComparable(T1s, T2s).
  comparable(ListType(T1), ListType(T2)) :- comparable(T1, T2).
  comparable(SupplierType(T1), SupplierType(T2)) :- comparable(T1, T2).
  comparable(T1, T2) :- orB(isAssignableTo(T1, T2), isAssignableTo(T2, T1)) == TRUE().

  /**
   * eraseType(T) = erased_type
   * erases TYPE [T] to TYPE [erased_type].
   * This removes all generic arguments and makes it nullable.
   * This also takes the upper bound of generic variables and wildcard.
   * Because there are no specific erased types, this just replaces everything
   * with UnitType if outright removing it is not possible.
   */
  eraseType : TYPE -> TYPE
  eraseTypes maps eraseType(list(*)) = list(*)
  eraseType(T) = makeNullable(eraseType_1(T)).

    eraseType_1 : TYPE -> TYPE
    eraseType_1(T) = T.
    eraseType_1(DataType(s_data)) = DataType(findGenericDef(s_data)).
    eraseType_1(NullableType(T)) = NullableType(eraseType_1(T)).
    eraseType_1(ListType(T)) = ListType(UnitType()).
    eraseType_1(TupleType(Ts)) = TupleType(replaceWithUnit(Ts)).
      getUnit : TYPE -> TYPE
      replaceWithUnit maps getUnit(list(*)) = list(*)
      getUnit(_) = UnitType().
    eraseType_1(SupplierType(_)) = SupplierType(UnitType()).
    eraseType_1(FuncType(_, params, _)) = FuncType([], replaceWithUnit(params), UnitType()).
    eraseType_1(WildcardType(ub, lb)) = typeOrTopType(ub).
    eraseType_1(T@GenericParameter2TYPE(_)) = eraseType(ub) :-
      getBounds(T) == (ub, _).

rules

  /**
   * typeOf(s, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you have a scope with type arguments, use typeOfWithTypeArgScope
   */
  typeOf : scope * Type -> TYPE
  typesOf maps typeOf(*, list(*)) = list(*)
  typeOf(s, ty) = typeOfWithTypeArgScope(s, emptyScope(s), ty, TRUE()). // should pass TRUE or FALSE?

  /**
   * typeOfWithTypeArgScope(s, s_type_args, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you don't have a scope with type arguments, use typeOf
   * If keep_uninstantiated is TRUE, generic parameters that are not
   * instantiated by a generic argument are returned as a
   * GenericParameter2TYPE(param@GenericParameter(scope, name)). If
   * keep_uninstantiated is FALSE generic parameters without matching arguments
   * return their upper bound.
   */
  typeOfWithTypeArgScope : scope * scope * Type * BOOLEAN -> TYPE
  typesOfWithTypeArgScope_1 maps typeOfWithTypeArgScope(*, *, list(*), *) = list(*)
  typeOfWithTypeArgScope(s, s_type_args, ty, keep_uninstantiated) =
    type@typeOfWithTypeArgScope_1(s, s_type_args, ty, keep_uninstantiated) :-
    @ty.type := type.

  typeOfWithTypeArgScope_1 : scope * scope * Type * BOOLEAN -> TYPE
  typeOfWithTypeArgScope_1(_, _, UnitTy(), _) = UnitType().
  typeOfWithTypeArgScope_1(_, _, BoolTy(), _) = BoolType().
  typeOfWithTypeArgScope_1(_, _, IntTy(), _)  = IntType().
  typeOfWithTypeArgScope_1(_, _, StrTy(), _)  = StrType().
  typeOfWithTypeArgScope_1(_, _, PathTy(), _) = PathType().
  typeOfWithTypeArgScope_1(s, s_type_args, DataTy2Type(data_ty), keep_uninstantiated) = typeOfDataTy(s, s_type_args, data_ty, keep_uninstantiated).
  typeOfWithTypeArgScope_1(s, s_type_args, TupleTy(tys), keep_uninstantiated) = TupleType(typesOfWithTypeArgScope_1(s, s_type_args, tys, keep_uninstantiated)).
  typeOfWithTypeArgScope_1(s, s_type_args, ListTy(ty), keep_uninstantiated) = ListType(typeOfWithTypeArgScope_1(s, s_type_args, ty, keep_uninstantiated)).
  typeOfWithTypeArgScope_1(s, s_type_args, SupplierTy(ty), keep_uninstantiated) = SupplierType(typeOfWithTypeArgScope_1(s, s_type_args, ty, keep_uninstantiated)).
  typeOfWithTypeArgScope_1(s, s_type_args, NullableTy(ty, marker), keep_uninstantiated) = NullableType(typeOfWithTypeArgScope_1(s, s_type_args, ty, keep_uninstantiated)) :-
    try { ty != NullableTy(_, _) } | warning $[No-op: double nullable has no effect] @marker.
  typeOfWithTypeArgScope_1(s, s_type_args, Wildcard(upper_bound, lower_bound), keep_uninstantiated) = WildcardType(upper_bound_ty, lower_bound_ty) :-
    {upper_error_node lower_error_node}
    typeOfUpperBound(s, s_type_args, upper_bound, keep_uninstantiated) == upper_bound_ty,
    typeOfLowerBound(s, s_type_args, lower_bound, keep_uninstantiated) == lower_bound_ty,
    bothBoundsOk(upper_bound, lower_bound).

      bothBoundsOk : UpperBound * LowerBound
      bothBoundsOk(_, _).
      bothBoundsOk(u@UpperBound(_), l@LowerBound(_)) :-
        false | error $[Cannot have both an upper and lower bound] @u,
        false | error $[Cannot have both an upper and lower bound] @l.

      typeOfUpperBound : scope * scope * UpperBound * BOOLEAN -> UpperBoundType
      typeOfUpperBound(_, _, NoUpperBound(), _) = NoUpperBoundType().
      typeOfUpperBound(s, s_type_args, UpperBound(upper_bound), keep_uninstantiated) =
        UpperBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, upper_bound, keep_uninstantiated))
      :-
        try { ty != WildcardType(_, _) } | error $[Cannot use wildcard as upper bound] @upper_bound,
        try { ty != UnitType()   } | warning $[Nonsensical bound: unit does not have subtypes] @upper_bound,
        try { ty != ListType(_)  } | warning $[Nonsensical bound: list types do not have subtypes] @upper_bound,
        try { ty != TupleType(_) } | warning $[Nonsensical bound: tuple types do not have subtypes] @upper_bound,
        try { ty != BottomType() } | warning $[Nonsensical bound: BOTTOM is the only matching type] @upper_bound.

      typeOfLowerBound : scope * scope * LowerBound * BOOLEAN -> LowerBoundType
      typeOfLowerBound(_, _, NoLowerBound(), _) = NoLowerBoundType().
      typeOfLowerBound(s, s_type_args, LowerBound(lower_bound), keep_uninstantiated) =
        LowerBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, lower_bound, keep_uninstantiated))
      :-
        try { ty != WildcardType(_, _) } | error $[Cannot use wildcard as lower bound] @lower_bound,
        try { ty != TopType() } | warning $[Nonsensical bound: TOP is the only matching type] @lower_bound.

  /**
   * typeOfDataTy(s, s_type_args, data_ty, keep_uninstantiated) = data_type
   * Get the Semantic type [data_type] of a synactic type [data_ty].
   * Uses [s] to resolve types and [s_type_args] to resolve type arguments.
   * If keep_uninstantiated is TRUE, generic parameters that are not
   * instantiated by a generic argument are returned as a
   * GenericParameter2TYPE(param@GenericParameter(scope, name)). If
   * keep_uninstantiated is FALSE generic parameters without matching arguments
   * return their upper bound.
   */
  typeOfDataTy : scope * scope * DataTy * BOOLEAN -> TYPE
  typeOfDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args), keep_uninstantiated) = type :-
    {resolved_params resolvedData}
    resolveGenericParam(s_type_args, name) == resolved_params,
    resolveData(mergeScopes(s, resolveModuleListToFile(s, modules)), name) == resolvedData,
    isGenericParamOrDataTy(s, s_type_args, data_ty, modules, resolved_params, resolvedData, keep_uninstantiated) == type.

    isGenericParamOrDataTy : scope * scope * DataTy * ModuleList *
      list((path * (GenericParameter * (TYPE * TYPE)))) * list((path * (TYPEID * scope))) * BOOLEAN -> TYPE
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, _, _) = DataType(emptyScope(s)) :-
      false | error $[Undefined datatype [name]] @name.

    // generic parameter
    isGenericParamOrDataTy(s, s_type_args, DataTy(NoModuleList(), name, type_args), NoModuleList(),
      [(_, (param@GenericParameter(_, name'), (upper_bound, _)))], _, keep_uninstantiated) = type :-
      genericParamToType(resolveTypeArgFromNameOnly(s_type_args, name), keep_uninstantiated, param, upper_bound) == type,
      @name.ref := name',
      @name.type := type,
      try { getTypeArgsList(type_args) == [] } | error "Generic parameters do not take type arguments" @type_args.

      genericParamToType : list((path * (GenericParameter * TYPE))) * BOOLEAN * GenericParameter * TYPE -> TYPE
      genericParamToType([], TRUE(), param, _) = GenericParameter2TYPE(param).
      genericParamToType([], FALSE(), _, upper_bound) = upper_bound. // should call instantiateTypeArgs?
      genericParamToType([(_, (_, ty))], _, _, _) = ty.
      genericParamToType([(_, (GenericParameter(_, name), _)),_|_], _, GenericParameter(s, _), _) = DataType(emptyScope(s)) :-
        false | error $[BUG: resolved multiple type arguments named [name]].

    isGenericParamOrDataTy(s, _, DataTy(_, name, type_args), NoModuleList(), [_,_|_], _, _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate declarations for generic parameter [name]] @name.

    // data type
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, [_,_|_], _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate datatype [name]] @name.
    isGenericParamOrDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args), _, _,
      [(_, (name', s_data_def))], keep_uninstantiated) = type@DataType(s_data_instance) :-
      {params}
      new s_data_instance,
      !root[getRoot(s)] in s_data_instance,
      s_data_instance -P-> s_data_def,
      getGenericParams(s_data_def) == params,
      genericArgsOk(s, s_type_args, s_data_instance, params, type_args, keep_uninstantiated, name),
      @name.ref := name',
      @name.type := type.

      // s: current function/module scope
      // s_type_args: scope for looking up defined data types
      // s_data_instance: scope for the instance that we are typing right now
      // s_data_def: definition for s_data_instance

  genericArgsOk : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) * TypeArgs * BOOLEAN * string
  genericArgsOk(_, _, _, [], NoTypeArgs(), _, _). // separate case to force unification of params before evaluating this.
  genericArgsOk(_, _, _, params@[_|_], NoTypeArgs(), _, error_node) :-
    {names}
    getGenericParamNames(params) == names,
    false | error $[Cannot derive type arguments. Provide type arguments explicitly for parameters [names]] @error_node.

    getGenericParamName : (GenericParameter * TYPE * TYPE) -> string
    getGenericParamNames maps getGenericParamName(list(*)) = list(*)
    getGenericParamName((GenericParameter(_, name), _, _)) = name.

  genericArgsOk(s, s_type_args, s_data_instance, params, type_args@TypeArgs(arg_types), keep_uninstantiated, _) :-
    genericArgsOk_1(s, s_type_args, s_data_instance, params, type_args, keep_uninstantiated, sameLength(params, arg_types)).

    sameLength : list((GenericParameter * TYPE * TYPE)) * list(Type) -> (list(TYPEID) * list(Type))
    sameLength([], []) = ([], []).
    sameLength([(GenericParameter(_, name), _, _)|params], []) = ([name|names], []) :-
      sameLength(params, []) == (names, []).
    sameLength([], remaining@[_|_]) = ([], remaining).
    sameLength([_|params], [_|type_args]) = sameLength(params, type_args).

  genericArgsOk_1 : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) *
    TypeArgs * BOOLEAN * (list(TYPEID) * list(Type))
  genericArgsOk_1(_, _, _, _, type_args, _, (remaining@[_|_], [])) :-
    false | error $[Not enough type arguments, unmatched generic arguments: [remaining]] @type_args.
  genericArgsOk_1(_, _, _, _, type_args, _, ([], remaining@[_|_])) :-
    false | error $[Too many type arguments, unmatched type arguments: [remaining]] @type_args.
  genericArgsOk_1(s, s_type_args, s_data_instance, params, TypeArgs(type_args), keep_uninstantiated, ([], [])) :-
    genericArgsOk_2(s, s_type_args, s_data_instance, params, type_args, keep_uninstantiated).

  genericArgOk : scope * scope * scope * (GenericParameter * TYPE * TYPE) * Type * BOOLEAN
  genericArgsOk_2 maps genericArgOk(*, *, *, list(*), list(*), *)
  genericArgOk(s, s_type_args, s_data_instance, (param@GenericParameter(_, name), upper_bound, lower_bound), arg, keep_uninstantiated) :-
    {arg_ty}
    typeOfWithTypeArgScope(s, s_type_args, arg, keep_uninstantiated) == arg_ty,
    declareTypeArg(s_data_instance, param, arg_ty),
    assignableTo(arg_ty, upper_bound) | error $[Type mismatch: [arg_ty] is not within upper bound [upper_bound] for type parameter [name]],
    assignableTo(lower_bound, arg_ty) | error $[Type mismatch: [arg_ty] is not within lower bound [lower_bound] for type parameter [name]].

  /**
   * instantiateTypeArgs(s, s_decl, T) = instantiated_type
   * instantiate [T] to a type [instantiated_type].
   * This recursively replaces every GenericParameter2TYPE(_). This will
   * replace every generic parameter in [s_decl] with its type argument if it
   * exists, then go to the next scope towards [s] and repeat until reaching
   * [s]. If no type argument exists it will use the upper bound of the type
   * parameter.
   */
  instantiateTypeArgs : scope * scope * TYPE -> TYPE
  instantiateTypeArgsInAll maps instantiateTypeArgs(*, *, list(*)) = list(*)
  instantiateTypeArgs(s, s, T) = instantiateTypeArgs_1(s, T, []).
  instantiateTypeArgs(s, s_decl, T) = res :-
    {s_cur instantiated possibly_s_next}
    query ()
      filter (INHERIT|P)*
         and { s_cur' :-
                 {matches}
                 query ()
                   filter P?
                       in s_cur' |-> matches,
                 containsScope(getScopes(matches), s_decl)
             }
         min $ < P
          in s |-> [(_, s_cur)],
    instantiateTypeArgs_1(s_cur, T, []) == instantiated,
    query ()
      filter (INHERIT|P)*
         and { s_next' :- query () filter P INHERIT in s_next' |-> [(_, s_cur)] }
          in s |-> possibly_s_next,
    instantiateTypeArgs_2(possibly_s_next, s, s_cur, instantiated) == res.

      containsScope : list(scope) * scope
      containsScope([], _) :- false.
      containsScope([s|_], s).
      containsScope([s'|rest], s) :- containsScope(rest, s).

    instantiateTypeArgs_1 : scope * TYPE * list(GenericParameter) -> TYPE
    instantiateTypeArgsInAll_1 maps instantiateTypeArgs_1(*, list(*), *) = list(*)
    instantiateTypeArgs_1(_, T, _) = T.
    instantiateTypeArgs_1(s, DataType(s_data), params) =
      DataType(instantiateGenericParams(s, s_data)).
    instantiateTypeArgs_1(s, TupleType(tys), params) = TupleType(instantiateTypeArgsInAll_1(s, tys, params)).
    instantiateTypeArgs_1(s, ListType(ty), params) = ListType(instantiateTypeArgs_1(s, ty, params)).
    instantiateTypeArgs_1(s, SupplierType(ty), params) = SupplierType(instantiateTypeArgs_1(s, ty, params)).
    instantiateTypeArgs_1(s, NullableType(ty), params) = NullableType(instantiateTypeArgs_1(s, ty, params)).
    instantiateTypeArgs_1(s, WildcardType(upper_bound, lower_bound), params) =
      WildcardType(
        instantiateTypeArgs_wildcardUpperbound(s, upper_bound, params),
        instantiateTypeArgs_wildcardLowerbound(s, lower_bound, params)
      ).

      instantiateTypeArgs_wildcardUpperbound : scope * UpperBoundType * list(GenericParameter) -> UpperBoundType
      instantiateTypeArgs_wildcardUpperbound(_, T@NoUpperBoundType(), _) = T.
      instantiateTypeArgs_wildcardUpperbound(s, UpperBoundType(ub), params) = UpperBoundType(instantiateTypeArgs_1(s, ub, params)).

      instantiateTypeArgs_wildcardLowerbound : scope * LowerBoundType * list(GenericParameter) -> LowerBoundType
      instantiateTypeArgs_wildcardLowerbound(_, T@NoLowerBoundType(), _) = T.
      instantiateTypeArgs_wildcardLowerbound(s, LowerBoundType(lb), params) = LowerBoundType(instantiateTypeArgs_1(s, lb, params)).

    instantiateTypeArgs_1(s, GenericParameter2TYPE(param@GenericParameter(s_param, _)), params) =
      instantiateTypeArgs_genericParameter(s, scope_equal, resolved_arg, param, [param|params], seen)
    :-
      isScopeEqual(findGenericDef(s), s_param) == scope_equal,
      resolveTypeArg(s, param) == resolved_arg,
      containsGenericParam(params, param) == seen.

      containsGenericParam : list(GenericParameter) * GenericParameter -> BOOLEAN
      containsGenericParam([], _) = FALSE().
      containsGenericParam([param|_], param) = TRUE().
      containsGenericParam([param'|params], param) = containsGenericParam(params, param).

      instantiateTypeArgs_genericParameter : scope * BOOLEAN * list((path * (GenericParameter * TYPE))) *
        GenericParameter * list(GenericParameter) * BOOLEAN -> TYPE
      instantiateTypeArgs_genericParameter(_, FALSE(), _, param, _, _) = GenericParameter2TYPE(param).
      instantiateTypeArgs_genericParameter(_, _, [], param, _, _) = GenericParameter2TYPE(param).
      instantiateTypeArgs_genericParameter(s, TRUE(), [(_, (_, T))], _, params, containsGenericParam) = instantiateTypeArgs_1(s, T, params) :-
        containsGenericParam == FALSE() | error $[bug: assumption that generic parameter with type argument has not been seen before is wrong].
      instantiateTypeArgs_genericParameter(s, TRUE(), [_,_|_], GenericParameter(_, name), _, _) = DataType(emptyScope(s)) :-
        false | error $[BUG: resolved multiple type arguments named [name]].

    instantiateTypeArgs_2 : list((path * scope)) * scope * scope * TYPE -> TYPE
    instantiateTypeArgs_2([], s, s_decl, T) = T.
    instantiateTypeArgs_2([(_, s_next)], s, s_decl, T) = instantiateTypeArgs(s, s_next, T).
