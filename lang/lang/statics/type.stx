module statics/type

imports

  signatures/constructors-sig
  signatures/data-sig
  signatures/type-sig
  statics/base
  statics/common
  statics/type_common
  statics/module

rules // operations on types

  /**
   * inherits(s_sub, s_super) -> res
   * Returns TRUE() if s_sub inherits from (can be reached by only following
   * INHERIT|P edges from) s_super or is equal to s_super, FALSE() otherwise.
   */
  inherits : scope * scope -> BOOLEAN
  inherits(s_sub, s_super) = inherits_1(paths) :-
    query () filter P? (INHERIT P)* INHERIT? and { s_data :- s_data == s_super } in s_sub |-> paths.

    inherits_1 : list((path * scope)) -> BOOLEAN
    inherits_1([]) = FALSE().
    inherits_1([_|_]) = TRUE().

  /**
   * assignableTo(T1, T2, assignableKind)
   * Checks if an expression of type [T1] can be assigned to a variable of type [T2].
   * Holds if type T1 is a non-strict subtype of type T2.
   * Fails with error if T1 is not a subtype of T2.
   */
  assignableTo : TYPE * TYPE * AssignableKind
  assignableTo(T1, T2, assignableKind) :-
    isAssignableTo(T1, T2, assignableKind) == TRUE().

  /**
   * isAssignableTo(T1, T2, assignableKind) = res
   * Checks if an expression of type [T1] can be assigned to a variable of type [T2].
   * todo: update
   * Returns TRUE() if:
   * - type T1 is a non-strict subtype of type T2
   * - T1 is a wildcard and its upper bound can be assigned to T2
   * - T2 is a wildcard and T1 can be assigned to the lower bound of T2
   * returns FALSE() otherwise.
   * May fail on unbound variables.
   */
  isAssignableTo : TYPE * TYPE * AssignableKind -> BOOLEAN
  isAssignableTo(BottomType(), BottomType(), _) = TRUE().
  isAssignableTo(BottomType(), _, InvariantKind()) = FALSE().
  isAssignableTo(BottomType(), _, TypeArgKind()) = TRUE().
  isAssignableTo(BottomType(), _, ExpressionKind()) = TRUE().
  isAssignableTo(T, T, _) = TRUE(). // optimization: a type is equal to itself, except for wildcards sometimes.
  isAssignableTo(T1@WildcardType(_, _, _), T2@WildcardType(_, _, _), assignable_kind) =
    // edge case for opimization: wildcards are tricky, do not use optimization.
    isAssignableTo_1(assignable_kind, T2, T1).
  isAssignableTo(T1, T2, assignable_kind) =
    isAssignableTo_1(assignable_kind, T2, T1).

    // isAssignableTo with arguments in reverse order so that AssignableKind
    // and type that is assigned to have priority for rule selection
    isAssignableTo_1 : AssignableKind * TYPE * TYPE -> BOOLEAN
    isAssignableTo_1(_, NullableType(_), NullType()) = TRUE().
    isAssignableTo_1(assignable_kind, NullableType(T2), T1) =
      isAssignableTo(T1, T2, assignable_kind).
    isAssignableTo_1(assignable_kind, NullableType(T2), NullableType(T1)) =
      isAssignableTo(T1, T2, assignable_kind).
    isAssignableTo_1(_, ListType(T2), ListType(T1)) =
      isAssignableTo(T1, T2, InvariantKind()).
    isAssignableTo_1(_, ListType(_), EmptyListType()) = TRUE().
    isAssignableTo_1(_, TupleType(T2s), TupleType(T1s)) =
      isAllAssignableTo(T1s, T2s, InvariantKind()).
    isAssignableTo_1(_, SupplierType(T2), SupplierType(T1)) =
      isAssignableTo(T1, T2, InvariantKind()).
    isAssignableTo_1(InvariantKind(), DataType(s2), DataType(s1)) =
      isAssignableTo_invariantDataTypes(same_generic_def, type_args, s2) :-
        isScopeEqual(findGenericDef(s1), findGenericDef(s2)) == same_generic_def,
        getTypeArgs(s1) == type_args.

      isAssignableTo_invariantDataTypes : BOOLEAN * list((GenericParameter * TYPE)) * scope -> BOOLEAN
      isAssignableTo_invariantDataTypes(FALSE(), _, _) = FALSE().
      isAssignableTo_invariantDataTypes(TRUE(), type_args, s2) =
        allTrue(isAssignableTo_invariantDataTypes_1s(type_args, s2)).

        isAssignableTo_invariantDataTypes_1 : (GenericParameter * TYPE) * scope -> BOOLEAN
        isAssignableTo_invariantDataTypes_1s maps isAssignableTo_invariantDataTypes_1(list(*), *) = list(*)
        isAssignableTo_invariantDataTypes_1((param, T1), s2) =
          isAssignableTo(T1, resolveUniqueTypeArg(s2, name, "no error node"), InvariantKind()).

    isAssignableTo_1(assignable_kind, DataType(s_super), DataType(s_sub)) =
      out@isAssignableTo_dataTypes(s_sub, s_super, inherits, type_args, s_super_def, assignable_kind)
    :-
      {tmp1 tmp2}
      tmp1 == ppScope(s_sub),
      tmp2 == ppScope(s_super),
      try{false}|note$[DEBUG - [tmp1] is assignable to [tmp2] == [out] == isAssignableTo_dataTypes([s_sub], [s_super], [inherits], [type_args], [s_super_def], [assignable_kind])],
      findGenericDef(s_super) == s_super_def,
      inherits(s_sub, s_super_def) == inherits,
      getTypeArgs(s_super) == type_args.

      /*
       * Explanation of implementation
       * 1. Make sure that they could be subtypes: if !inherits(s_sub, findGenericDef(s_super)) then FALSE()
       * 2. If s_super is a definition, s_sub is a subtype by definition: if getTypeArgs(s_super) == [] then TRUE()
       * 3. Else: s_super is an instance. Find s_super_def by following P edge: getGenericDef(s_super) == s_super_def
       *    [note] s_sub is either an instance of s_super_def, or an instance or generic def of a strict subtype of s_super_def.
       * 4. Get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def:
       *    query ()
       *      filter INHERIT? (P INHERIT)*
       *         and { s :- getGenericDef(s) == s_super_def }
       *          in s_sub |-> [(_, s_sub_super_instance)]
       * 5. Check if instances are compatible: isTypeArgsCompatible(s_sub_super_instance, s_super)
       */
      isAssignableTo_dataTypes : scope * scope * BOOLEAN * list((GenericParameter * TYPE)) * scope * AssignableKind -> BOOLEAN
      isAssignableTo_dataTypes(s_data, s_data, TRUE(), _, _, _) = TRUE(). // optimization: s_sub == s_super
      isAssignableTo_dataTypes(_, _, FALSE(), _, _, _) = FALSE(). // s_sub does not inherit from the generic def of s_super, not subtypes
      isAssignableTo_dataTypes(_, _, TRUE(), [], _, _) = TRUE().  // s_super does not have type arguments and s_sub inherits from s_super_def
      isAssignableTo_dataTypes(s_sub, s_super, TRUE(), [_|_], s_super_def, assignableKind) =
        isTypeArgsCompatible(instantiated_s_sub_super_instance, s_super, assignableKind)
      :-
        {s_sub_super_instance}
        query ()
          filter INHERIT? (P INHERIT)*
             and { s :- getGenericDef(s) == s_super_def }
              in s_sub |-> [(_, s_sub_super_instance)],
        instantiateGenericParams(s_sub, s_sub_super_instance, Bound()) == instantiated_s_sub_super_instance.

        // instantiate generic parameters in instance s2 with the type arguments of s1
        instantiateGenericParams : scope * scope * CaptureState -> scope
        instantiateGenericParams(s1, s2, capture_state) = s_data_instance_instantiated :-
          {instantiated}
          new s_data_instance_instantiated,
          !root[getRoot(s2)] in s_data_instance_instantiated,
          s_data_instance_instantiated -P-> findGenericDef(s2),
          instantiateNamedTypeArgs(s1, s2, capture_state, getTypeArgs(s2)) == instantiated,
          declareTypeArgsFromTuples(s_data_instance_instantiated, instantiated).

          instantiateNamedTypeArg : scope * scope * CaptureState * (GenericParameter * TYPE) -> (GenericParameter * TYPE)
          instantiateNamedTypeArgs maps instantiateNamedTypeArg(*, *, *, list(*)) = list(*)
          instantiateNamedTypeArg(s1, s2, capture_state, (name, T)) = (name, instantiateTypeArgs_1(s1, T, capture_state, [])).

          declareTypeArgsFromTuples : scope * list((GenericParameter * TYPE))
          declareTypeArgsFromTuples(_, []).
          declareTypeArgsFromTuples(s, [(name, T)|args]) :-
            declareTypeArg(s, name, T),
            declareTypeArgsFromTuples(s, args).

      // check if s1 is compatible with s2. Assumes s1 is an instance of data
      // type dt and that s2 is either also an instance or the generic definition
      // "Compatible" means that the types are equal, or the second one is a
      // wildcard and the first one falls within the bounds
      isTypeArgsCompatible : scope * scope * AssignableKind -> BOOLEAN
      isTypeArgsCompatible(s1, s2, assignableKind) =
        isTypeArgsCompatible_1(s1, s2, getGenericDef(s1), assignableKind).

        // s1 is an instance
        // s2 is either an instance or a data definition.
        // third argument (s2/s_data_def) is data definition
        isTypeArgsCompatible_1 : scope * scope * scope * AssignableKind -> BOOLEAN
        isTypeArgsCompatible_1(s1, s2, s2, _) = TRUE().
          // s2 is a generic data definition, s1 is an instance of it.
          // s1 is a subtype by definition.

        isTypeArgsCompatible_1(s1, s2, s_data_def, assignableKind) =
          // s2 is an instance of s_data_def
          allTrue(isTypeArgsCompatible_2(tmp1@getTypeArgs(s1), s2, assignableKind)) :-
          {tmp2}
          tmp2 == ppScope(s1),
          try{false}|note$[DEBUG - type arguments in [tmp2]: [tmp1]].

        // Checks if a type argument in s1 is compatible with s2.
        isTypeArgCompatible : (GenericParameter * TYPE) * scope * AssignableKind -> BOOLEAN
        isTypeArgsCompatible_2 maps isTypeArgCompatible(list(*), *, *) = list(*)
        isTypeArgCompatible((name, ty1), s2, assignableKind) =
          out@isTypeArgCompatible_1(ty1, ty2@resolveUniqueTypeArg(s2, name, "no error node"), assignableKind) :-
            try{false}|note$[DEBUG - type arg [ty1] for parameter [name] is compatible with [ty2] == [out]].

          // note: not equivalent to assignableTo(T1, T2, TypeArgKind())
          // DataTypes are not allowed to be subtypes, they have to be equal or wildcards.
          isTypeArgCompatible_1 : TYPE * TYPE * AssignableKind -> BOOLEAN
          isTypeArgCompatible_1(ty, ty, _) = TRUE().
          isTypeArgCompatible_1(DataType(s1), DataType(s2), assignableKind) = andB(
              isScopeEqual(getGenericDef(s1), getGenericDef(s2)),
              isTypeArgsCompatible(s1, s2, assignableKind)
            ).
          isTypeArgCompatible_1(T, WildcardType(ub, lb, Free()), assignable_kind) =
              withinBounds(getBounds(T), (typeOrTopType(ub), typeOrBottomType(lb)), assignable_kind).
          isTypeArgCompatible_1(T, WildcardType(_, lb, Bound()), assignableKind) =
              isAssignableTo(T, typeOrBottomType(lb), assignableKind).
          isTypeArgCompatible_1(T1, T2@GenericParameter2TYPE(_), assignable_kind) =
              withinBounds(getBounds(T1), getBounds(T2), assignable_kind).
          isTypeArgCompatible_1(T1, T2, _) = FALSE().

    isAssignableTo_1(InvariantKind(), TopType(), TopType()) = TRUE() :-
      try {false} | warning $[BUG?: incorrect assumption that isAssignableTo_1(InvariantKind(), TopType(), TopType()) is never called because it is caught by isAssignableTo(T, T, _)].
    isAssignableTo_1(InvariantKind(), TopType(), _) = FALSE().
    isAssignableTo_1(TypeArgKind(), TopType(), _) = TRUE().
    isAssignableTo_1(ExpressionKind(), TopType(), _) = TRUE().

    isAssignableTo_1(assignable_kind, T, WildcardType(upper_bound, _, _)) =
      isAssignableTo(typeOrTopType(upper_bound), T, assignable_kind).
    isAssignableTo_1(InvariantKind(), T@WildcardType(_, _, _), T@WildcardType(_, _, _)) = FALSE() :-
      false | error $[BUG: incorrect assumption that isAssignableTo will never be called with a wildcard and InvariantKind].
    isAssignableTo_1(_, T@WildcardType(_, _, Free()), T@WildcardType(_, _, _)) = TRUE().
    isAssignableTo_1(TypeArgKind(), WildcardType(upper_bound, lower_bound, _), T) =
      withinBounds(getBounds(T), (typeOrTopType(upper_bound), typeOrBottomType(lower_bound)), TypeArgKind()) :-
        try { false } | warning $[BUG?: incorrect assumption that isAssignableTo_1(TypeArgKind(), WildcardType(upper_bound, lower_bound, _), T) will not be called. Check if there is a difference between bound and free wildcard].
    isAssignableTo_1(ExpressionKind(), WildcardType(upper_bound, _, Free()), T) =
      isAssignableTo(T, typeOrTopType(upper_bound), ExpressionKind()).
    isAssignableTo_1(ExpressionKind(), WildcardType(_, lower_bound, Bound()), T) =
      isAssignableTo(T, typeOrBottomType(lower_bound), ExpressionKind()).

    isAssignableTo_1(InvariantKind(), _, GenericParameter2TYPE(_)) = FALSE().
    isAssignableTo_1(assignable_kind, T2, T1@GenericParameter2TYPE(tmp3)) =
      out@isAssignableTo(upper_bound, T2, assignable_kind) :-
        {s name} tmp3 == GenericParameter(s, name),
        {tmp1} tmp1 == ppTYPE(upper_bound),
        {tmp2} tmp2 == ppTYPE(T2),
        try{false}|note$[DEBUG - generic parameter [name] in [s] with upper bound [tmp1] ([upper_bound]) is assignable to [tmp2] ([T2]) == [out]],
        getBounds(T1) == (upper_bound, _).
    isAssignableTo_1(_, T@GenericParameter2TYPE(_), T@GenericParameter2TYPE(_)) = TRUE() :-
      {name}
      T == GenericParameter2TYPE(GenericParameter(_, name)),
      try{false}|note$[DEBUG - generic parameter [name] is assignable to itself],
      try {false} | warning $[BUG?: incorrect assumption that isAssignableTo_1(_, T@GenericParameter2TYPE(_), T@GenericParameter2TYPE(_)) is never called because it is caught by isAssignableTo(T, T, _)].
    isAssignableTo_1(TypeArgKind(), T2@GenericParameter2TYPE(_), T1) =
      out@withinBounds(tmp1@getBounds(T1), tmp2@getBounds(T2), TypeArgKind()) :-
        {s name} T2 == GenericParameter2TYPE(GenericParameter(s, name)),
        {ub1 lb1} (ub1, lb1) == tmp1,
        {ub2 lb2} (ub2, lb2) == tmp2,
        {tmp3} tmp3 == ppTYPE(ub1),
        {tmp4} tmp4 == ppTYPE(lb1),
        {tmp5} tmp5 == ppTYPE(ub2),
        {tmp6} tmp6 == ppTYPE(lb2),
        {tmp7} tmp7 == ppTYPE(T1),
        try{false}|note$[DEBUG - [tmp7] ([T1]) is assignable to generic parameter [name] in [s] with upper bound [tmp5] ([ub1]) == [out]].
    isAssignableTo_1(ExpressionKind(), T2@GenericParameter2TYPE(_), T1) =
      isAssignableTo(T1, lower_bound, ExpressionKind()) :-
        getBounds(T2) == (_, lower_bound).

  // todo: remove comments
  // foo<T>(elem: T)

  // func bar1<F : Fruit>() -> {
  //   foo<F>(apple) // disallowed: F could be banana
  //                 // No argument type except bottom type would make this call legal
  // }
  // func bar2<F -: Fruit>() -> {
  //   foo<F>(apple) // allowed
  // }

  /*

  In one case, the type parameter is bound to a particular value, and assigning is only allowed if the argument is that particular value.
  In the other case, the type parameter is unbound, and the argument just has to fall within the bounds.
  Cases:
  - In all cases, a wildcard is just a type parameter that is not used anywhere else. (correct?)
  - override check: check if bounds for type parameters are compatible.
    - Could have free type parameters from functions, sub datatype.
    - All bounds should be exactly equal.
    - type parameters considered equal if occurence equal after renaming.
  - override check: check if parameters are compatible.
    - Could have free type parameters from functions, sub datatype.
    - All parameters should be exactly equal.
    - type parameters considered equal if occurence equal after renaming.
  - override check: check if return types are compatible.
    - Could have free type parameters from functions, sub datatype.
    - sub return type must be subtype of super return type.
    - type parameters considered equal if occurence equal after renaming.
  - assign type argument (from call or type reference) to type parameter.
    - Could have free type parameters from function type params or from datatype for super type declaration.
    - argument should be compatible: argument upper and lower bound within parameter upper and lower bound.
    - type parameters considered compatible if argument upper and lower bound within parameter upper and lower bound.
  - assign argument (from call) to parameter.
    - Can have free type parameters from function that makes the call: func foo<T>() -> bar<T>()
    - expression type should be compatible: expression type upper bound within declared type _lower_ bound or equal generic param occurence.
    - type parameters considered compatible if expression type upper and lower bound within declared type upper and lower bound.
  - assign expression to value (valDec).
    - Could have free type parameters from function type params.
    - expression type should be compatible: expression type upper bound within declared type upper bound. (lower bound does not matter because of subtyping)
    - type parameters considered compatible if expression type upper and lower bound within declared type upper and lower bound.

  */

    isAssignableTo_1(_, _, _) = FALSE().

  /**
   * isAllAssignableTo(T1s, T2s, assignableKind) -> bool
   * Returns TRUE if the types in [T1s] are pairwise assignable to [T2s], FALSE
   * otherwise. Also returns FALSE if the lists don't have the same length.
   * This is useful for comparing parameter lists of functions.
   * Delegates to isAssignableTo.
   */
  isAllAssignableTo : list(TYPE) * list(TYPE) * AssignableKind -> BOOLEAN
  isAllAssignableTo([], [], _) = TRUE().
  isAllAssignableTo(Ts@[_|_], [], _) = FALSE().
  isAllAssignableTo([], Ts@[_|_], _) = FALSE().
  isAllAssignableTo([T1|T1s], [T2|T2s], assignableKind) =
    andB(isAssignableTo(T1, T2, assignableKind), isAllAssignableTo(T1s, T2s, assignableKind)).

  /**
   * lub(T1, T2)
   * Returns the least upper bound of types [T1] and [T2].
   */
  lub : TYPE * TYPE -> TYPE
  lubs maps lub(list(*), list(*)) = list(*)
  lub(NullType(), T) = makeNullable(T).
  lub(T, NullType()) = makeNullable(T).
  lub(NullableType(T1), NullableType(T2)) = NullableType(lub(T1, T2)).
  lub(EmptyListType(), ListType(T)) = ListType(T).
  lub(ListType(T), EmptyListType()) = ListType(T).
  lub(T1@DataType(_), T2@DataType(_)) =
    lub_dataTypeGuard(isAssignableTo(T1, T2, TypeArgKind()), isAssignableTo(T2, T1, TypeArgKind()), T1, T2).

    lub_dataTypeGuard : BOOLEAN * BOOLEAN * TYPE * TYPE -> TYPE
    lub_dataTypeGuard(TRUE(), _, _, T2) = T2.
    lub_dataTypeGuard(_, TRUE(), T1, _) = T1.
    lub_dataTypeGuard(FALSE(), FALSE(), T1@DataType(s1), T2@DataType(s2)) =
      lub_datatype(maybe_s_common, s1, s2)
    :-
      // find all scopes from s1 that s2 inherits from, take the shortest one.
      // This is guaranteed to be a generic definition unless one of the two is a subtype of the other,
      // or they do not have an explicit common super type.
      // them being subtypes is already covered by lub_dataTypeGuard
      query ()
        filter (P|INHERIT)*
           and { s_common_candidate :- inherits(s2, s_common_candidate) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> maybe_s_common.

    // list contains either no scopes or single scope s_data_common, which is a definition
    lub_datatype : list((path * scope)) * scope * scope -> TYPE
    lub_datatype([], _, _) = TopType().
    lub_datatype([(_, s_common)], s1, s2) = DataType(s_common_instance) :-
      {s3 s4 type_arg_params type_arg_tys merged_type_args}
      new s_common_instance,
      !root[getRoot(s_common)] in s_common_instance,
      s_common_instance -P-> s_common,
      query ()
        filter (P|INHERIT)*
           and { s3_candidate :- isInstanceOf(s3_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> [(_, s3)],
      query ()
        filter (P|INHERIT)*
           and { s4_candidate :- isInstanceOf(s4_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s2 |-> [(_, s4)],
      unzipTypeArgs(getTypeArgs(s3)) == (type_arg_params, type_arg_tys),
      lubs_type_args(type_arg_tys, resolveUniqueTypeArgs(s4, type_arg_params, "no error node")) == merged_type_args,
      declareTypeArgs(s_common_instance, type_arg_params, merged_type_args).

        isInstanceOf: scope * scope -> BOOLEAN
        isInstanceOf(s1, s2) = isInstanceOf_listContains(occs, s2) :-
          query () filter P in s1 |-> occs.

          isInstanceOf_listContains : list((path * scope)) * scope -> BOOLEAN
          isInstanceOf_listContains([], _) = FALSE().
          isInstanceOf_listContains([(_, s)|_], s) = TRUE().
          isInstanceOf_listContains([(_, s')|rest], s) = isInstanceOf_listContains(rest, s).

        unzipTypeArgs : list((GenericParameter * TYPE)) -> (list(GenericParameter) * list(TYPE))
        unzipTypeArgs([]) = ([], []).
        unzipTypeArgs([(param, type)|type_args]) = ([param|params], [type|types]) :-
          unzipTypeArgs(type_args) == (params, types).

        lub_type_arg : TYPE * TYPE -> TYPE
        lubs_type_args maps lub_type_arg(list(*), list(*)) = list(*)
        lub_type_arg(T1, T2) = lub_type_arg_1(T1, T2, compatible1, compatible2) :-
          isTypeArgCompatible_1(T2, T1, TypeArgKind()) == compatible1,
          isTypeArgCompatible_1(T1, T2, TypeArgKind()) == compatible2.

          lub_type_arg_1 : TYPE * TYPE * BOOLEAN * BOOLEAN -> TYPE
          lub_type_arg_1(T, T, _, _) = T.
          lub_type_arg_1(T1, _, TRUE(), _) = T1.
          lub_type_arg_1(_, T2, _, TRUE()) = T2.
          lub_type_arg_1(T1, T2, FALSE(), FALSE()) =
            WildcardType(UpperBoundType(lub(ub1, ub2)), NoLowerBoundType(), Free()) :-
              getBounds(T1) == (ub1, _),
              getBounds(T2) == (ub2, _).

  lub(TopType(), T) = TopType().
  lub(T, TopType()) = TopType().
  lub(BottomType(), T) = T.
  lub(T, BottomType()) = T.
  lub(WildcardType(upper_bound, _, _), T) = lub(typeOrTopType(upper_bound), T).
  lub(T, WildcardType(upper_bound, _, _)) = lub(T, typeOrTopType(upper_bound)).
  lub(T, T) = T.
  lub(T@GenericParameter2TYPE(_), T@GenericParameter2TYPE(_)) = T.
  lub(T1@GenericParameter2TYPE(_), T2) = lub(ub, T2) :-
    getBounds(T1) == (ub, _).
  lub(T1, T2@GenericParameter2TYPE(_)) = lub(T1, ub) :-
    getBounds(T2) == (ub, _).
  lub(T1, T2) = firstTrueT([
    (isAssignableTo(T1, T2, ExpressionKind()), T2),
    (isAssignableTo(T2, T1, ExpressionKind()), T1)],
    TopType()).


  /**
   * listLub(list)
   * Returns the least upper bound of a list of types.
   */
  listLub : list(TYPE) -> TYPE
  listLub([]) = BottomType() :- try { false } | warning "BUG?: called listLub with empty list".
  listLub([T]) = T.
  listLub([T1|[T2|[]]]) = lub(T1, T2).
  listLub([T1|[T2|rest]]) = listLub([lub(T1, T2) | rest]).

  /**
   * Holds if the two types are comparable.
   * This disregards the possibilty for two incomparable but Nullable values to
   * both be null and the possibilty for two list types to both be empty lists.
   */
  comparable : TYPE * TYPE
  listComparable maps comparable(list(*), list(*))
  comparable(TupleType(T1s), TupleType(T2s)) :- listComparable(T1s, T2s).
  comparable(ListType(T1), ListType(T2)) :- comparable(T1, T2).
  comparable(SupplierType(T1), SupplierType(T2)) :- comparable(T1, T2).
  comparable(T1, T2) :-
    orB(isAssignableTo(T1, T2, ExpressionKind()), isAssignableTo(T2, T1, ExpressionKind())) == TRUE().

rules

  /**
   * typeOf(s, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you have a scope with type arguments, use typeOfWithTypeArgScope
   */
  typeOf : scope * Type -> TYPE
  typesOf maps typeOf(*, list(*)) = list(*)
  typeOf(s, ty) = typeOfWithTypeArgScope(s, emptyScope(s), ty, FALSE()).

  /**
   * typeOfWithTypeArgScope(s, s_type_args, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you don't have a scope with type arguments, use typeOf
   * [resolve_in_super_types] specifies if type arguments can be looked up in
   * super types or not. If they can, resolution will follow P and INHERIT
   * edges. Otherwise, it will only follow P edges.
   */
  typeOfWithTypeArgScope : scope * scope * Type * BOOLEAN -> TYPE
  typesOfWithTypeArgScope maps typeOfWithTypeArgScope(*, *, list(*), *) = list(*)
  typeOfWithTypeArgScope(s, s_type_args, ty, resolve_in_super_types) =
    type@typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types) :-
    @ty.type := type.

  typeOfWithTypeArgScope_1 : scope * scope * Type * BOOLEAN -> TYPE
  typesOfWithTypeArgScope_1 maps typeOfWithTypeArgScope_1(*, *, list(*), *) = list(*)
  typeOfWithTypeArgScope_1(_, _, UnitTy(), _) = UnitType().
  typeOfWithTypeArgScope_1(_, _, BoolTy(), _) = BoolType().
  typeOfWithTypeArgScope_1(_, _, IntTy(), _)  = IntType().
  typeOfWithTypeArgScope_1(_, _, StrTy(), _)  = StrType().
  typeOfWithTypeArgScope_1(_, _, PathTy(), _) = PathType().
  typeOfWithTypeArgScope_1(s, s_type_args, DataTy2Type(data_ty), resolve_in_super_types) = typeOfDataTy(s, s_type_args, data_ty, resolve_in_super_types).
  typeOfWithTypeArgScope_1(s, s_type_args, TupleTy(tys), resolve_in_super_types) = TupleType(typesOfWithTypeArgScope_1(s, s_type_args, tys, resolve_in_super_types)).
  typeOfWithTypeArgScope_1(s, s_type_args, ListTy(ty), resolve_in_super_types) = ListType(typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types)).
  typeOfWithTypeArgScope_1(s, s_type_args, SupplierTy(ty), resolve_in_super_types) = SupplierType(typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types)).
  typeOfWithTypeArgScope_1(s, s_type_args, NullableTy(ty, marker), resolve_in_super_types) = NullableType(typeOfWithTypeArgScope_1(s, s_type_args, ty, resolve_in_super_types)) :-
    try { ty != NullableTy(_, _) } | warning $[No-op: double nullable has no effect] @marker.
  typeOfWithTypeArgScope_1(s, s_type_args, Wildcard(upper_bound, lower_bound), resolve_in_super_types) = WildcardType(upper_bound_ty, lower_bound_ty, Free()) :-
    {upper_error_node lower_error_node}
    typeOfUpperBound(s, s_type_args, upper_bound, resolve_in_super_types) == upper_bound_ty,
    typeOfLowerBound(s, s_type_args, lower_bound, resolve_in_super_types) == lower_bound_ty,
    bothBoundsOk(upper_bound, lower_bound).

  /**
   * typeOfDataTy(s, s_type_args, data_ty, resolve_in_super_types) = data_type
   * Get the Semantic type [data_type] of a syntactic type [data_ty].
   * Uses [s] to resolve types and [s_type_args] to resolve type arguments.
   * [resolve_in_super_types] specifies if type arguments can be looked up in
   * super types or not. If they can, resolution will follow P and INHERIT
   * edges. Otherwise, it will only follow P edges.
   */
  typeOfDataTy : scope * scope * DataTy * BOOLEAN -> TYPE
  typeOfDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args), resolve_in_super_types) = type :-
    {resolved_params resolvedData}
    resolveGenericParam(s_type_args, name) == resolved_params,
    resolveData(mergeScopes(s, resolveModuleListToFile(s, modules)), name) == resolvedData,
    isGenericParamOrDataTy(s, s_type_args, data_ty, modules, resolved_params, resolvedData, resolve_in_super_types) == type.

    isGenericParamOrDataTy : scope * scope * DataTy * ModuleList *
      list((path * (GenericParameter * (TYPE * TYPE)))) * list((path * (TYPEID * scope))) * BOOLEAN -> TYPE
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, _, _) = DataType(emptyScope(s)) :-
      false | error $[Undefined datatype [name]] @name.

    // generic parameter
    isGenericParamOrDataTy(s, s_type_args, DataTy(NoModuleList(), name, type_args), NoModuleList(),
      [(_, (param@GenericParameter(_, name'), (upper_bound, _)))], _, resolve_in_super_types) = type :-
      genericParamToType(resolveTypeArgFromNameOnly(s_type_args, name, resolve_in_super_types), param, upper_bound) == type,
      @name.ref := name',
      @name.type := type,
      getTypeArgsList(type_args) == [] | error "Generic parameters do not take type arguments" @type_args.

      genericParamToType : list((path * (GenericParameter * TYPE))) * GenericParameter * TYPE -> TYPE
      genericParamToType([], param, _) = GenericParameter2TYPE(param).
      genericParamToType([(_, (_, ty))], _, _) = ty.
      genericParamToType([(_, (GenericParameter(_, name), _)),_|_], GenericParameter(s, _), _) = DataType(emptyScope(s)) :-
        false | error $[BUG: resolved multiple type arguments named [name]].

    isGenericParamOrDataTy(s, _, DataTy(_, name, type_args), NoModuleList(), [_,_|_], _, _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate declarations for generic parameter [name]] @name.

    // data type
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, [_,_|_], _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate datatype [name]] @name.
    isGenericParamOrDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args), _, _,
      [(_, (name', s_data_def))], resolve_in_super_types) = type@DataType(s_data_instance) :-
      {params}
      new s_data_instance,
      !root[getRoot(s)] in s_data_instance,
      s_data_instance -P-> s_data_def,
      getGenericParams(s_data_def) == params,
      genericArgsOk(s, s_type_args, s_data_instance, params, type_args, resolve_in_super_types, name),
      @name.ref := name',
      @name.type := type.

      // s: current function/module scope
      // s_type_args: scope for looking up defined data types
      // s_data_instance: scope for the instance that we are typing right now
      // s_data_def: definition for s_data_instance

  /**
   * genericParamsOk(s, s_data_def, GenericParams(params)) = generic_params
   * Checks that the declared type parameters are ok. Returns a list
   * [generic_params] of the resolved type parameters with their bounds.
   * - Declares the type parameters in [s_def].
   * - Declares each individual type parameter in [s_def].
   * - Checks that there are no duplicate names for the type parameters. This
   *   includes declared type parameters in (parents of) scope [s]. Gives an
   *   error if a name is a duplicate.
   * - Checks that each parameter has at most one bound.
   * - Resolves the type of each bound in scope [s].
   * - Gives a note if the type parameter shadows a datatype name in [s].
   */
  genericParamsOk : scope * scope * GenericParams -> list(GenericParamType)
  genericParamsOk(s, s_def, GenericParams(params)) = wrapBounds(parameters) :-
    typeOfgenericParams(s, s_def, params) == parameters,
    !generic_params[parameters] in s_def.
    
    wrapBound : (GenericParameter * TYPE * TYPE) -> GenericParamType
    wrapBounds maps wrapBound(list(*)) = list(*)
    wrapBound((GenericParameter(_, name), upper_bound, lower_bound)) =
      GenericParamType(name, typeToUpperBoundType(upper_bound), typeToLowerBoundType(lower_bound)).

    typeOfgenericParam : scope * scope * GenericParam -> (GenericParameter * TYPE * TYPE)
    typeOfgenericParams maps typeOfgenericParam(*, *, list(*)) = list(*)
    typeOfgenericParam(s, s_def, GenericParam(name, upper_bound, lower_bound)) = (param, upper_bound_ty, lower_bound_ty) :-
      {upper_error_node lower_error_node}
      bothBoundsOk(upper_bound, lower_bound),
      typeOrTopType(typeOfUpperBound(s, s_def, upper_bound, FALSE())) == upper_bound_ty,
      typeOrBottomType(typeOfLowerBound(s, s_def, lower_bound, FALSE())) == lower_bound_ty,
      declareGenericParam(s_def, name, upper_bound_ty, lower_bound_ty) == param,
      try { resolveData(s, name) == [] } | note $[Generic parameter [name] shadows data type [name]] @name.

      bothBoundsOk : UpperBound * LowerBound
      bothBoundsOk(_, _).
      bothBoundsOk(u@UpperBound(_), l@LowerBound(_)) :-
        false | error $[Cannot have both an upper and lower bound] @u,
        false | error $[Cannot have both an upper and lower bound] @l.

      typeOfUpperBound : scope * scope * UpperBound * BOOLEAN -> UpperBoundType
      typeOfUpperBound(_, _, NoUpperBound(), _) = NoUpperBoundType().
      typeOfUpperBound(s, s_type_args, UpperBound(upper_bound), resolve_in_super_types) =
        UpperBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, upper_bound, resolve_in_super_types))
      :-
        try { ty != WildcardType(_, _, _) } | error $[Cannot use wildcard as upper bound] @upper_bound,
        try { ty != UnitType()   } | warning $[Nonsensical bound: unit does not have subtypes] @upper_bound,
        try { ty != ListType(_)  } | warning $[Nonsensical bound: list types do not have subtypes] @upper_bound,
        try { ty != TupleType(_) } | warning $[Nonsensical bound: tuple types do not have subtypes] @upper_bound,
        try { ty != BottomType() } | warning $[Nonsensical bound: BOTTOM is the only matching type] @upper_bound.

      typeOfLowerBound : scope * scope * LowerBound * BOOLEAN -> LowerBoundType
      typeOfLowerBound(_, _, NoLowerBound(), _) = NoLowerBoundType().
      typeOfLowerBound(s, s_type_args, LowerBound(lower_bound), resolve_in_super_types) =
        LowerBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, lower_bound, resolve_in_super_types))
      :-
        try { ty != WildcardType(_, _, _) } | error $[Cannot use wildcard as lower bound] @lower_bound,
        try { ty != TopType() } | warning $[Nonsensical bound: TOP is the only matching type] @lower_bound.


  genericArgsOk : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) * TypeArgs * BOOLEAN * string
  genericArgsOk(_, _, _, [], NoTypeArgs(), _, _). // separate case to force unification of params before evaluating this.
  genericArgsOk(_, _, _, params@[_|_], NoTypeArgs(), _, error_node) :-
    {names}
    getGenericParamNames(params) == names,
    false | error $[Cannot derive type arguments. Provide type arguments explicitly for parameters [names]] @error_node.

    getGenericParamName : (GenericParameter * TYPE * TYPE) -> string
    getGenericParamNames maps getGenericParamName(list(*)) = list(*)
    getGenericParamName((GenericParameter(_, name), _, _)) = name.

  genericArgsOk(s, s_type_args, s_data_instance, params, type_args@TypeArgs(arg_types), resolve_in_super_types, _) :-
    genericArgsOk_1(s, s_type_args, s_data_instance, params, type_args, resolve_in_super_types, sameLength(params, arg_types)).

    sameLength : list((GenericParameter * TYPE * TYPE)) * list(Type) -> (list(TYPEID) * list(Type))
    sameLength([], []) = ([], []).
    sameLength([(GenericParameter(_, name), _, _)|params], []) = ([name|names], []) :-
      sameLength(params, []) == (names, []).
    sameLength([], remaining@[_|_]) = ([], remaining).
    sameLength([_|params], [_|type_args]) = sameLength(params, type_args).

  genericArgsOk_1 : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) *
    TypeArgs * BOOLEAN * (list(TYPEID) * list(Type))
  genericArgsOk_1(_, _, _, _, type_args, _, (remaining@[_|_], [])) :-
    false | error $[Not enough type arguments, unmatched generic arguments: [remaining]] @type_args.
  genericArgsOk_1(_, _, _, _, type_args, _, ([], remaining@[_|_])) :-
    false | error $[Too many type arguments, unmatched type arguments: [remaining]] @type_args.
  genericArgsOk_1(s, s_type_args, s_data_instance, params, TypeArgs(type_args), resolve_in_super_types, ([], [])) :-
    genericArgsOk_2(s, s_type_args, s_data_instance, params, type_args, resolve_in_super_types).

  genericArgOk : scope * scope * scope * (GenericParameter * TYPE * TYPE) * Type * BOOLEAN
  genericArgsOk_2 maps genericArgOk(*, *, *, list(*), list(*), *)
  genericArgOk(s, s_type_args, s_data_instance, (param@GenericParameter(_, name), upper_bound, lower_bound), arg, resolve_in_super_types) :-
    {arg_ty}
    {tmp1} tmp1 == isAssignableTo(arg_ty, upper_bound, TypeArgKind()),
    {tmp2} tmp2 == isAssignableTo(lower_bound, arg_ty, TypeArgKind()),
    {tmp3 tmp4}
    tmp3 == ppTYPE(upper_bound),
    tmp4 == ppTYPE(lower_bound),
    try{false}|note$[DEBUG - checking [arg] for param [name] --> [arg_ty]. Assignable to upper bound [tmp3] ([upper_bound]) == [tmp1], to lower bound [tmp4] ([lower_bound]) == [tmp2] --- s_type_args: [s_type_args]],
    typeOfWithTypeArgScope(s, s_type_args, arg, resolve_in_super_types) == arg_ty,
    declareTypeArg(s_data_instance, param, arg_ty),
    try { tmp1 == TRUE() } | error $[Type mismatch: [arg_ty] is not within upper bound [upper_bound] for type parameter [name]],
    try { tmp2 == TRUE() } | error $[Type mismatch: [arg_ty] is not within lower bound [lower_bound] for type parameter [name]].

  /**
   * instantiateTypeArgs(s, T) = instantiated_type
   * instantiate [T] to a type [instantiated_type].
   * This recursively and exhaustively replaces GenericParameter2TYPE(_) with
   * its type argument. If no type argument exists it will leave the generic
   * parameter as is. This is used when checking if a method overrides another.
   */
  instantiateTypeArgs : scope * TYPE -> TYPE
  instantiateTypeArgsInAll maps instantiateTypeArgs(*, list(*)) = list(*)
  instantiateTypeArgs(s, T) = instantiateTypeArgs_1(s, T, Free(), []).

    instantiateTypeArgs_1 : scope * TYPE * CaptureState * list(GenericParameter) -> TYPE
    instantiateTypeArgsInAll_1 maps instantiateTypeArgs_1(*, list(*), *, *) = list(*)
    instantiateTypeArgs_1(_, UnitType(), _, _) = UnitType().
    instantiateTypeArgs_1(_, BoolType(), _, _) = BoolType().
    instantiateTypeArgs_1(_, IntType(), _, _) = IntType().
    instantiateTypeArgs_1(_, StrType(), _, _) = StrType().
    instantiateTypeArgs_1(_, PathType(), _, _) = PathType().
    instantiateTypeArgs_1(_, NullType(), _, _) = NullType().
    instantiateTypeArgs_1(_, TopType(), _, _) = TopType().
    instantiateTypeArgs_1(_, BottomType(), _, _) = BottomType().
    instantiateTypeArgs_1(s, DataType(s_data), capture_state, params) =
      DataType(instantiateGenericParams(s, s_data, capture_state)).
    instantiateTypeArgs_1(s, TupleType(tys), capture_state, params) = TupleType(instantiateTypeArgsInAll_1(s, tys, capture_state, params)).
    instantiateTypeArgs_1(s, ListType(ty), capture_state, params) = ListType(instantiateTypeArgs_1(s, ty, capture_state, params)).
    instantiateTypeArgs_1(_, EmptyListType(), _, _) = EmptyListType().
    instantiateTypeArgs_1(s, SupplierType(ty), capture_state, params) = SupplierType(instantiateTypeArgs_1(s, ty, capture_state, params)).
    instantiateTypeArgs_1(s, NullableType(ty), capture_state, params) = NullableType(instantiateTypeArgs_1(s, ty, capture_state, params)).
    instantiateTypeArgs_1(s, WildcardType(upper_bound, lower_bound, _), capture_state, params) =
      WildcardType(
        instantiateTypeArgs_wildcardUpperbound(s, upper_bound, capture_state, params),
        instantiateTypeArgs_wildcardLowerbound(s, lower_bound, capture_state, params),
        capture_state
      ).
    instantiateTypeArgs_1(s, WildcardType(upper_bound, lower_bound, Bound()), _, params) =
      WildcardType(
        instantiateTypeArgs_wildcardUpperbound(s, upper_bound, Bound(), params),
        instantiateTypeArgs_wildcardLowerbound(s, lower_bound, Bound(), params),
        Bound()
      ).

      instantiateTypeArgs_wildcardUpperbound : scope * UpperBoundType * CaptureState * list(GenericParameter) -> UpperBoundType
      instantiateTypeArgs_wildcardUpperbound(_, T@NoUpperBoundType(), _, _) = T.
      instantiateTypeArgs_wildcardUpperbound(s, UpperBoundType(ub), capture_state, params) =
        UpperBoundType(instantiateTypeArgs_1(s, ub, capture_state, params)).

      instantiateTypeArgs_wildcardLowerbound : scope * LowerBoundType * CaptureState * list(GenericParameter) -> LowerBoundType
      instantiateTypeArgs_wildcardLowerbound(_, T@NoLowerBoundType(), _, _) = T.
      instantiateTypeArgs_wildcardLowerbound(s, LowerBoundType(lb), capture_state, params) =
        LowerBoundType(instantiateTypeArgs_1(s, lb, capture_state, params)).

    instantiateTypeArgs_1(s, GenericParameter2TYPE(param@GenericParameter(s_param, _)), _, params) =
      instantiateTypeArgs_genericParameter(s, resolved_arg, param, [param|params], seen)
    :-
      resolveTypeArg(s, param) == resolved_arg,
      containsGenericParam(params, param) == seen.

      containsGenericParam : list(GenericParameter) * GenericParameter -> BOOLEAN
      containsGenericParam([], _) = FALSE().
      containsGenericParam([param|_], param) = TRUE().
      containsGenericParam([param'|params], param) = containsGenericParam(params, param).

      instantiateTypeArgs_genericParameter : scope * list((path * (GenericParameter * TYPE))) *
        GenericParameter * list(GenericParameter) * BOOLEAN -> TYPE
      instantiateTypeArgs_genericParameter(_, [], param, _, _) = GenericParameter2TYPE(param).
      instantiateTypeArgs_genericParameter(s, [_], param, params, TRUE()) = GenericParameter2TYPE(param).
      instantiateTypeArgs_genericParameter(s, [(_, (_, T))], _, params, FALSE()) = instantiateTypeArgs_1(s, T, Bound(), params).
      instantiateTypeArgs_genericParameter(s, [_,_|_], GenericParameter(_, name), _, _) = DataType(emptyScope(s)) :-
        false | error $[BUG: resolved multiple type arguments named [name]].
