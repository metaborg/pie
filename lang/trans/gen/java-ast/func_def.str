module gen/java-ast/func_def

imports

  libspoofax/stratego/debug

  signatures/-
  signatures/lex/-
  signatures/impl/-

  signatures/java/expressions/-
  signatures/java/names/-
  signatures/java/types/-
  signatures/java/classes/-
  signatures/java/interfaces/-

  gen/java-ast/type
  gen/java-ast/func_body
  gen/idtype-tuples
  gen/util

rules // PIE function definitions

  // p2j-ast-def:
  //   FuncDef(FuncHead(funcId, params, type), PieFuncImpl(body, optKeyBody)) ->
  //   Java class implementing TaskDef AST node
  // Tranforms a Pie function into a Pie Task (i.e. a Java class implementing TaskDef)
  // Adds to the dynamic strategy ModuleBindings
  // Defines the dynamic rules InputKind and InjectValues
  // InputKind is either 0, 1, or 2, it reflects the number of parameter for this function
  // (2 is used for anything greater than 1)
  // InjectValues are the values that will be injected
  // into the constructor of the Java class
  p2j-ast-def:
    FuncDef(FuncHead(funcId, params, type), PieFuncImpl(body, optKeyBody)) -> result
    with
      <debug(|"start p2j-ast-def: ")> funcId
    ; className   := <pie-sanitize-class-id> funcId
    with
    {| InputKind, InjectValues:
      (inputType, inputDataClasses)   := <p2j-ast-pie-func-impl-inputsig(|className)> params
    ; (outputType, outputDataClasses) := <p2j-ast-pie-func-impl-outputsig(|className)> type
    ; (stmts, lastValue)              := <p2j-ast-pie-func-impl-body> body
    ; keyImpl                         := <p2j-ast-pie-func-key-body> optKeyBody
    ; injectTuples                    := <bagof-InjectValues; make-set>
    ; fields                          := <map(type-tuple-to-ast-field)> injectTuples
    ; constructorParams               := <create-ast-formal-params> injectTuples
    ; assignments                     := <map(type-tuple-to-ast-assignment)> injectTuples
    ; returnValue                     := <?UnitTy(); !<p2j-ast-exp> UnitLit() <+ !lastValue> type
   |}
    with
      rules(ModuleBindings :+= Invoke(
          "bindTaskDef"
        , [TypeNameClassLiteral(TypeName(className), []), StrLit(className)]
        )
      )
      // Note: meaning of this AST: bindTaskDef([className].class, "[className]");
    with
      result := ClassDeclaration(
          []
        , className
        , None()
        , None()
        , [ClassType([], "TaskDef", Some(TypeArguments([inputType, outputType])))]
        , <concat> [
            [ FieldDecl(
                [Private(), Static(), Final()]
              , ClassType("String", None())
              , VariableDeclInit("_id", StrLit(className))
              )
            ]
          , fields
          , [ ConstrDecl(
                [MarkerAnno(TypeName("Inject"))]
              , None()
              , className
              , constructorParams
              , None()
              , None()
              , assignments
              )
            ]
          , inputDataClasses
          , outputDataClasses
          , [ MethodDecl(
                [Public()]
              , MethodHeader(TypeName("String"), "getId", NoParams(), [], None())
              , Block(Return(Field(This(), "_id")))
              )
            , MethodDecl(
                [MarkerAnno(TypeName("Override")), Public()]
              , MethodHeader(
                  TypeName("Serializable")
                , "key"
                , SingleParam(FormalParam([], inputType, "input"))
                , []
                , None()
                )
              , Block(keyImpl)
              )
            , MethodDecl(
                [MarkerAnno(TypeName("Override")), Public()]
              , MethodHeader(
                  outputType
                , "exec"
                , ParamList(
                    FormalParam([], TypeName("ExecContext"), "execContext")
                  , FormalParam([], inputType, "input")
                  )
                , []
                , None()
                )
              , Block(<concat> [stmts, [Return(returnValue)]])
              )
            ]
          ]
        )
    // Note: meaning of this AST:
    //   class [className] implements TaskDef<[inputType], [outputType]> {
    //     private static final String _id = "[className]";
    //     [fields]
    //     
    //     @Inject
    //     [className](
    //       [constructorParams]
    //     ) {
    //       [assignments]
    //     }
    //     
    //     [inputDataClasses]
    //     
    //     [outputDataClasses]
    //     
    //     public String getId() {
    //       return this._id;
    //     }
    //     
    //     @Override
    //     public Serializable key([inputType] input) {
    //       [keyImpl]
    //     }
    //     
    //     @Override
    //     public [outputType] exec(ExecContext execContext, [inputType] input) throws Exception {
    //       try {
    //         [stmts]
    //         return [returnValue];
    //       } catch (Util.WrapperException e) {
    //         throw e.getWrappedException();
    //       }
    //     }
    //   }
    ; <debug(|"end p2j-ast-def: ")> funcId

  // p2j-ast-pie-func-impl-body(): Block(exps)|EmptyBlock()|<Exp> ->
  //   (list of Java statements, Java return value AST node)
  // converts the body of a Pie function to a list of Java statements
  // and a return value
  p2j-ast-pie-func-impl-body():
    Block(exps) -> result
    with
      numExps                := <length> exps
    ; restExps               := <take(|<dec> numExps)> exps
    ; restStmts              := <map(try-p2j-ast-exp); map(Fst); concat> restExps
    ; lastExp                := <last> exps
    ; (lastStmt, lastExpVal) := <p2j-ast-pie-func-impl-returnvalue> lastExp
    ; stmts                  := <concat> [restStmts, lastStmt]
    ; result                 := (stmts, lastExpVal)

  p2j-ast-pie-func-impl-body():
    exp -> result
    where
      <not(?Block(_))> exp
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; returnValue        := <p2j-ast-pie-func-impl-returnvalue> expVal
    ; result             := (expStmts, returnValue)

  // p2j-ast-pie-func-impl-returnvalue: Pie exp -> (Java Statements, Java expression)
  // Converts a Pie expression to a Java expression for returning
  // (Used because a Tuple may not be returned directly but 
  // must be converted to the correct ouput type)
  p2j-ast-pie-func-impl-returnvalue:
    exp -> result
    where
      <pie-ast-type; (?TupleTy(_) <+ NullableTy(?TupleTy(_)))> exp
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; resultExp          := InvokeQExp(ExpressionName(Id("Output")), None(), Id("fromTuple"), [expVal])
      // Note: meaning of this AST: Output.fromTuple([expVal])
    ; result             := (expStmts, resultExp)

  p2j-ast-pie-func-impl-returnvalue:
    exp -> <try-p2j-ast-exp> exp
    where
      <pie-ast-type; not(?TupleTy(_)); not(NullableTy(?TupleTy(_)))> exp

  // p2j-ast-pie-func-impl-inputsig(|className):
  //   Params(params) -> (inputType, list of dataClasses)
  // Takes a Pie Params constructor and returns the Java function input type
  // for the class className (String) and a list of dataclasses
  // (note: always 0 or 1 dataclass, it's a list to prevent having to match
  // on None / Some)
  // This also sets the dynamic rule InputKind
  p2j-ast-pie-func-impl-inputsig(|className):
    Params(params) -> (<p2j-ast-type-sig> UnitTy(), [])
    where
      0 := <length> params
    with 
      rules(InputKind := 0)
      
  p2j-ast-pie-func-impl-inputsig(|className):
    p@Params(params) -> (tySig, [])
    where
      1 := <length> params
    with
      [(_, ty)] := <pie-idtype-tuples> p
    ; tySig     := <p2j-ast-type-sig> ty
    with 
      rules(InputKind := 1)
    
  p2j-ast-pie-func-impl-inputsig(|className):
    p@Params(params) -> result
    where
      length := <length> params
    ; <gt> (length, 1)
    with
      idTypeTuples := <pie-idtype-tuples> p
    ; dataClass    := <p2j-ast-type-generate-dataclass(|"Input")> idTypeTuples
    ; inputType    := ClassOrInterfaceTypeMember(ClassType([], Id(className), None()), [], Id("Input"), None())
      // Note: meaning of this AST: [className].Input
    ; result       := (inputType, [dataClass])
    with
      rules(InputKind := 2)

  // p2j-ast-pie-func-impl-outputsig(|className):
  //   Pie type -> (Java Type, list of Java (data)class declaration AST nodes)
  // Converts a Pie type into the corresponding Java return type
  // for the given class (className) and a list of dataclasses
  // There is either 0 or 1 dataclass, but they are in a list
  // to avoid having to match on None and Some
  p2j-ast-pie-func-impl-outputsig(|className):
    ty -> (<java-classType-to-unnanType> <p2j-ast-type-sig> ty, [])
    where
      <not(?TupleTy(_)); not(?NullableTy(TupleTy(_)))> ty
      
  p2j-ast-pie-func-impl-outputsig(|className):
    ty -> result
    where
      tty := <is-tuple-type> ty
    with
      returnType   := ClassOrInterfaceTypeMember(
          ClassType([], Id(className), None())
        , []
        , Id("Output")
        , None()
      )
      // Note: meaning of this AST: [className].Output
    ; idTypeTuples := <pie-idtype-tuples> tty
    ; dataClass    := <p2j-ast-type-generate-dataclass(|"Output")> idTypeTuples
    ; result       := (returnType, [dataClass])
  
  // is-tuple-type: matches a Tuple type
  is-tuple-type: tty@TupleTy(_)             -> tty
  is-tuple-type: NullableTy(tty@TupleTy(_)) -> tty
  

  // p2j-ast-pie-func-key-body: PieKeyFunc(exp)? -> list of Java statament AST nodes
  // generates a list of statements for the body of the key function
  p2j-ast-pie-func-key-body:
    None() -> Return(ExpressionName(Id("input")))

  p2j-ast-pie-func-key-body:
    PieKeyFunc(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; result             := <concat> [expStmts, [Return(expVal)]]
      // Note: meaning of these statements: [expStmts]["\n"]return [expVal];
